<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>垃圾回收</title>
      <link href="/posts/learn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/posts/learn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h3><h4 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h4><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效减 1。引用计数为 0 的对象可被回收 </p><p>两个对象出现循环引用，此时计数器永远不为 0，导致无法回收</p><p>正因为循环引用的存在，因此 Java 虚拟机不适用引用计数算法</p><h4 id="2-可达性分析"><a href="#2-可达性分析" class="headerlink" title="2. 可达性分析"></a>2. 可达性分析</h4><p>通过 GC Root 作为起始点进行搜索，能够到达的对象都是存活的，不可达的对象可被回收</p><p>Java 虚拟机用该算法判断对象是否可被回收，一般包含以下内容</p><ul><li>虚拟机栈引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h4 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3. 方法区的回收"></a>3. 方法区的回收</h4><p>主要是堆常量池的回收和类卸载</p><p>类卸载的条件很多，需要满足以下三个条件，并且满足了也不一定被卸载</p><ul><li>该类所有实例都已经被回收，也就是堆中不存在该类实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 Class 对象没有在任何地方被引用</li></ul><p>可以通过 -Xnoclassgc 参数控制是否堆类进行卸载</p><h4 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4. finalize()"></a>4. finalize()</h4><p>finalize() 类似 c++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做得更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不使用</p><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法还是可达性算法，判定对象是否可被回收都与引用有关</p><p>Java 具有四种强度不同的引用</p><h4 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h4><p>被强引用关联的对象不会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><h4 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h4><p>被软引用关联的对象只有在内存不够时被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h4 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h4><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记-清除"></a>1. 标记-清除</h4><p>将存活对象进行标记，然后清理掉未被标记的对象</p><p>不足：</p><ul><li>标记和清除过程效率不高</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存</li></ul><h4 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记-整理"></a>2. 标记-整理</h4><p>让所有存活的对象都向一端移动，然后直接清理掉端边界外的内存</p><h4 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h4><p>将内存一分为二，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>主要不足是只使用了内存的一半。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p><h4 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h4><p>根据对象存活周期将内存划分为几块，不同块采用适当的收集算法</p><p>一般将堆分为新生代和老年代</p><ul><li>新生代使用 复制算法</li><li>老年代使用 标记-清除 或 标记-整理</li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记-清除算法</p><p>四个流程</p><ol><li><strong>初始标记</strong>：仅标记 GC Root 能直接关联到的对象，<strong>需要停顿</strong></li><li><strong>并发标记</strong>：进行 GC Root Tracing 的过程，在整个回收过程中耗时最长，不需要停顿</li><li><strong>重新标记</strong>：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象标记记录，需要停顿</li><li><strong>并发清除</strong>：不需要停顿</li></ol><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>以下缺点：</p><ul><li>吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能</p><p>其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收</p><p>G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize&#x3D;n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区</p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p>流程</p><ol><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong> ：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行</li><li><strong>筛选回收</strong> : 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率</li></ol><p>特点：</p><ul><li>空间整合：整体看是基于「标记-整理」算法实现，从局部(两个 Region 之间) 基于「复制」算法实现，这意味着不会产生空间碎片</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片内，消耗在 GC 上的时间不超过 N 毫秒</li></ul><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="1-对象优先分配在-Eden-区"><a href="#1-对象优先分配在-Eden-区" class="headerlink" title="1. 对象优先分配在 Eden 区"></a>1. 对象优先分配在 Eden 区</h4><p>当 Eden 区空间不够时，发起 Minor GC</p><h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p><code>-XX:PretenureSizeThreshold</code> ，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p><h4 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在 Minor GC 依然存活会移动到 S区，年龄增加 1 岁，增加到一定年龄就移动到老年代中</p><p><code>-XX:MaxTenuringThreshold</code> 用来定义年龄的阈值</p><h4 id="4-动态对象年龄判断"><a href="#4-动态对象年龄判断" class="headerlink" title="4. 动态对象年龄判断"></a>4. 动态对象年龄判断</h4><p>虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄</p><h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC</p><h4 id="6-Full-GC-条件"><a href="#6-Full-GC-条件" class="headerlink" title="6. Full GC 条件"></a>6. Full GC 条件</h4><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件</p><h5 id="1-调用System-gc"><a href="#1-调用System-gc" class="headerlink" title="1. 调用System.gc()"></a>1. 调用System.gc()</h5><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定执行</p><h5 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h5><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 <code>-Xmn</code> 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间</p><h5 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h5><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC</p><h5 id="4-jdk-1-7-及以前永久代空间不足"><a href="#4-jdk-1-7-及以前永久代空间不足" class="headerlink" title="4. jdk 1.7 及以前永久代空间不足"></a>4. jdk 1.7 及以前永久代空间不足</h5><h5 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h5><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC</p><h2 id="详解-G1-和-CMS"><a href="#详解-G1-和-CMS" class="headerlink" title="详解 G1 和 CMS"></a>详解 G1 和 CMS</h2><p>todo</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/posts/learn/JVM/"/>
      <url>/posts/learn/JVM/</url>
      
        <content type="html"><![CDATA[<p>摘抄自<a href="https://www.nenggz.com/md/java/jvm/java-jvm-struct.html">这里</a></p><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><ul><li>线程私有：程序计数器、虚拟机栈、本地方法区</li><li>线程共享：堆、方法区、堆外内存(JDK 7 的永久代或 JDK 8 的元空间、代码缓存)</li></ul><h3 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h3><p>程序计数寄存器(Program Counter Register)，起名源于 CPU 的寄存器，寄存器存储指令相关线程信息，CPU只有把数据装载到寄存器才能够运行</p><p>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</p><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码行号指示器</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码，由执行引擎读取指令</p><blockquote><p>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</p></blockquote><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><blockquote><p>PC寄存器为什么会被设定为线程私有的？</p></blockquote><p>多线程在一个特定的时间段只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会中断或恢复。<strong>为了能准确记录各个线程正在执行的字节码指令地址</strong>，所以要私有，线程独立计算</p><blockquote><p>总结</p></blockquote><ul><li>一块很小的内存空间，运行速度最快的存储区域</li><li>在 JVM 规范中，程序计数器是线程私有的，生命周期与线程的生命周期一致</li><li>任何时间一个线程只有一个方法在执行，也就是所谓<strong>当前方法</strong>。如果执行Java方法则指向 JVM 字节码指令地址，如果执行 native 方法，则未指定值(undefined)</li><li>是程序控制流的指示器</li><li><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></li></ul><h3 id="二、虚拟机栈"><a href="#二、虚拟机栈" class="headerlink" title="二、虚拟机栈"></a>二、虚拟机栈</h3><p>主管 Java 程序的运行，保存方法的局部变量、部分结果，并参与方法的调用和返回</p><p>特点：</p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<font color=blue>入栈</font>，方法执行结束，伴随着<font color=blue>出栈</font></li><li><strong>栈不存在垃圾回收问题</strong></li></ul><p><strong>栈可能出现的问题</strong></p><p>Java 虚拟机规范允许 <strong>Java 虚拟机栈的大小是动态的或者是固定不变的</strong></p><ul><li>如果采用固定大小，那么栈容量在线程创建时就确定好，超过最大容量则抛出 <code>StackOverflowError</code></li><li>如果可以动态扩展，并且在尝试扩展时无法申请足够的内存，或创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么会抛出 <code>OutOfMemoryError</code></li></ul><p>可以通过参数 <code>-Xss</code> 来设置线程的最大栈空间，栈的大小直接决定函数调用的最大可达深度</p><h4 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h4><p>栈中存储什么？</p><ul><li>每隔线程都有自己的栈，栈中的数据都是以<strong>栈帧(Stack Frame)</strong> 的格式存在</li><li>在这个线程上正在执行的每个方法各自有对应的栈帧</li><li>栈帧是一块内存区块，是一个数据集，维系着方法执行过程中的各种数据</li></ul><h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><ul><li>JVM 直接堆 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循 FIFO 原则</li><li>在一条活动线程中，一个时间点上，只有一个活动的栈帧，即 <strong>栈顶栈帧</strong></li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>Java 方法有两种返回函数，<strong>一种是正常的函数返回，使用 return ，另一种是抛异常，不管是哪种方式，都会导致栈帧被弹出</strong></li></ul><h4 id="栈帧内部结构"><a href="#栈帧内部结构" class="headerlink" title="栈帧内部结构"></a>栈帧内部结构</h4><p>栈帧存储着：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接 (指向运行时常量池的方法引用)</li><li>方法返回值 (正常退出或异常退出的地址)</li><li>附加信息</li></ul><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><ul><li>局部变量表也称为本地变量表</li><li>是一组变量值存储空间，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 Java 虚拟机<strong>基本数据类型</strong>、<strong>对象引用</strong> 和 <strong>returnAddress</strong> 类型 (指向了一条字节码指令的地址，已被异常表取代)</li><li>局部变量表建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需要的容量大小是编译时期确定下来的</strong>，并保存在 Code 属性的 <code>maximum local variables</code> 数据项中</li><li><strong>栈越大，方法嵌套调用次数越多</strong></li><li><strong>局部变量表的变量只在当前栈(当前方法)调用中有效</strong></li><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束</li></ul><h5 id="槽-Slot"><a href="#槽-Slot" class="headerlink" title="槽 Slot"></a>槽 Slot</h5><ul><li>局部变量表最基本的存储单元是 Slot(变量槽)</li><li>32位以内的类型只占用一个Slot(包含returnAddress类型)，64位的类型(long 和 double) 占用两个连续的 Slot</li><li>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过索引即可成功访问局部变量表指定的局部变量表，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</li><li>当一个实例方法被调用，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每个 Slot 上</li><li><strong>如果需要访问局部变量表中一个 64 bit 的局部变量表值，只需要使用前一个索引即可</strong></li><li>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为this 变量不存在于当前方法的局部变量表中）</li><li><strong>栈帧的局部变量表中的槽位可以复用</strong>，如果一个变量表过了其作用域，那么很有可能复用过期槽位，<strong>达到节省资源</strong></li><li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li></ul><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><ul><li>每个独立栈帧中除了包含局部变量表外，包含一个<strong>后进先出</strong>的操作数栈，也可以称为<strong>表达式栈</strong></li><li><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈、出栈</strong></li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</li></ul><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul><li><font color=blue>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></font></li><li>每个操作数栈拥有明确栈深度用于存储数值，在编译期就定义好了，保存在方法的 Code 属性的 <code>max_stack</code> 里</li><li><code>栈单位也是槽</code></li><li><code>如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中</code></li><li><code>Java 虚拟机的解释引擎时基于操作数栈的执行引擎</code></li></ul><h5 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h5><p><strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率</strong></p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><ul><li><p>每一个栈帧内包含一个指向运行时常量池中该栈帧所属方法的引用</p></li><li><p>在 Java 源文件被编译到字节码文件中，所有的变量和方法引用都作为 <strong>符号引用</strong> 保存在 Class 文件的常量池中。 <font color=blue>动态链接的作用就是将这些符号引用转化为调用方法的直接引用</font><br><img src="/img/learn/jvm/dtlj.jpg" alt="动态链接"></p></li><li><p><strong>静态链接</strong>：目标方法在编译期可知，则将调用方法的符号引用转换为直接引用的过程称之为静态链接</p></li><li><p><strong>动态链接</strong>：目标方法在运行期才能确定，则将调用方法的符号引用转换为直接引用的过程称之为动态链接</p></li></ul><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</strong></p><ul><li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong></li><li>晚期绑定：<strong>晚期绑定就是指被调用的目标方法在运行期才能确定，且可能因为运行期状态而发生变化时</strong></li></ul><h5 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h5><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li></ul><h4 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h4><p>用来存放调用该方法的 PC 寄存器的值</p><p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong></p><p><strong>通过异常完成出口退出的不会给它的上层调用者产生任何返回值</strong></p><h3 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h3><p>一个 Native Method 就是一个 Java 调用非 Java 代码接口</p><ul><li>Java 虚拟机用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</li><li>本地方法栈也是私有的</li><li><strong>允许线程固定或者动态扩展内存大小(同虚拟机栈一样)</strong></li><li>本地方法用 C 语言实现的</li><li><font color=blue>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</font></li></ul><blockquote><p><strong>栈是运行时的单位，而堆是存储单位</strong><br>栈解决程序运行问题，如程序如何执行；而堆是解决数据存储问题，数据怎么放、放在哪</p></blockquote><h3 id="四、堆内存"><a href="#四、堆内存" class="headerlink" title="四、堆内存"></a>四、堆内存</h3><p>Java 堆是虚拟机管理的内存中最大的一块，被所有线程共享，此内存区域的唯一目的是存放对象实例，<strong>几乎所有对象实例在这里分配内存</strong></p><p>为了提高垃圾回收效率，虚拟机把堆内存<strong>逻辑上</strong>划分为三块区域(<font color=blue>分代的唯一理由是优化 GC 性能</font>)</p><ul><li>新生代：新对象和没到达一定年龄的对象</li><li>老年代：被长时间使用的对象</li><li>元空间(1.8 之前叫永久代)：像一些方法的操作临时对象等， JDK 1.8 之前是占用 JVM 内存，之后直接使用物理内存<br><img src="/img/learn/jvm/jvm-heap.png" alt="Java堆内存"></li></ul><p>Java 堆可以是处于物理上不连续的内存空间，只要逻辑上连续即可，像磁盘空间一样；实现时，可以是固定大小，也可以是可扩展，主流虚拟机都是可以扩展的(通过 <code>-Xmx</code> 和 <code>Xms</code> )，如果堆中没有完成实例分配，并且堆再无内存扩展时，就会抛出 <code>OutOfMemoryError</code> </p><h4 id="新生代-Young-Generation"><a href="#新生代-Young-Generation" class="headerlink" title="新生代(Young Generation)"></a>新生代(Young Generation)</h4><p>所有新对象创建的地方，当填充年轻代时，执行垃圾收集。这种收集叫 <code>Minor GC</code> 。</p><p>年轻代被划分为三个部分，伊甸园（Eden Memory）和两个幸存区（Survivor Memory，被称为from&#x2F;to或s0&#x2F;s1），默认比例是 <code>8:1:1</code></p><ul><li>大多数新创建对象位于 Eden 区</li><li>当 Eden 空间被对象填充时，执行 Minor GC，并将所有幸存者对象移动到一个幸存者空间中</li><li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li><li>经过多次 GC 循环后存活的对象被移动到老年代。通过，这是通过<strong>设置年轻一代对象的年龄阈值来实现</strong></li></ul><h4 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代(Old Generation)"></a>老年代(Old Generation)</h4><p>存放旧的一代内存经过多轮 <code>Minor GC</code> 存活的对象。通常，垃圾收集是在老年代内存满时执行。老年代垃圾收集称为 主 GC(Major GC)，通常需要更长时间</p><p>大对象直接进入老年代。这样做避免在 Eden 区和两个 Survivor 区之间发生大量内存拷贝</p><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>不管是永久代和元空间，都可以看着做是 Java 虚拟机规范中方法区的实现</p><h4 id="设置堆内存大小和-OOM"><a href="#设置堆内存大小和-OOM" class="headerlink" title="设置堆内存大小和 OOM"></a>设置堆内存大小和 OOM</h4><ul><li><code>-Xms</code>：设置 Java 堆内存的起始内存</li><li><code>-Xmx</code>：设置 Java 堆内存的最大内存</li></ul><p>如果堆的内存大小超过 <code>-Xmx</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常</p><p>我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为<strong>相同的值</strong>，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p><h4 id="查看-JVM-堆内存分配"><a href="#查看-JVM-堆内存分配" class="headerlink" title="查看 JVM 堆内存分配"></a>查看 JVM 堆内存分配</h4><ol><li>默认情况下新生代和老年代的比例是 1：2，可以通过 <code>-XX:NewRatio</code> 配置</li><li>新生代中 Eden:Survivor0:Survivor1 的比例可以通过 <code>-XX:SurvivorRatio</code> 配置</li><li>JDK 8 是默认开启 <code>-XX:+UseAdaptiveSizePolicy</code> ，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄;此时 <code>–XX:NewRatio </code> 和 <code>-XX:SurvivorRatio</code> 将会失效</li></ol><p>每次 GC 后都会重新计算 Eden、 From Survivor、 To Survivor 的大小</p><p>计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量</p><h4 id="对象在堆中的生命周期"><a href="#对象在堆中的生命周期" class="headerlink" title="对象在堆中的生命周期"></a>对象在堆中的生命周期</h4><ol><li>当创建一个对象时，对象会优先分配到新生代的 Eden 区<br>· 此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（ <code>-XX:MaxTenuringThreshold</code> ）</li><li>当 Eden 空间不足时， JVM 将执行新生代垃圾回收(Minor GC)<br>  · JVM 会把存活对象转移到 Survivor 中，并且对象年龄 + 1<br>  · 对象在 Survivor 中同样会经历 Minor GC，每经历一次，对象年龄 + 1</li><li>如果分配的对象超过了 <code>-XX:PetenureSizeThreshold</code> ，对象会<strong>直接被分配到老年代</strong></li></ol><h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><ul><li>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</li><li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li></ul><h5 id="TLAB-好处"><a href="#TLAB-好处" class="headerlink" title="TLAB 好处"></a>TLAB 好处</h5><ul><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p><p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小</p><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p><h4 id="堆是分配内存的唯一选择吗？"><a href="#堆是分配内存的唯一选择吗？" class="headerlink" title="堆是分配内存的唯一选择吗？"></a>堆是分配内存的唯一选择吗？</h4><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p><strong>逃逸分析(Escape Analysis)是目前 Java 虚拟机中比较前沿的优化技术。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</strong></p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则没有发生逃逸</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则发生逃逸。如作为调用参数传递到其他地方，称为方法逃逸</li></ul><p>使用逃逸分析，编译器会对代码做优化：</p><ul><li><strong>栈上分配</strong>：将堆分配转化为栈分配</li><li><strong>同步省略</strong>：如果只能从一个线程访问，不做同步考虑</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li></ul><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p><p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p><h6 id="同步省略-消除"><a href="#同步省略-消除" class="headerlink" title="同步省略(消除)"></a>同步省略(消除)</h6><p>同步省略也叫锁消除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">synchronized</span>(keeper) &#123;</span><br><span class="line">    System.out.println(keeper);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，代码中对 keeper 这个对象进行加锁，但是 keeper 对象的生命周期只在 keep()方法中，并不会被其他线程所访问到，所以在 JIT编译阶段就会被优化掉。优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  System.out.println(keeper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h6><p>标量 指一个无法再分解成更小数据的数据。Java 中的原始数据类型是标量</p><p>相对的，可以分解的数据叫做 聚合量</p><p>在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是标量替换。</p><p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>（<span class="number">1</span>,<span class="number">2</span>）;</span><br><span class="line">   System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x+<span class="string">&quot;; point.y=&quot;</span>+point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，point 对象并没有逃逸出 alloc() 方法，并且 point 对象是可以拆解成标量的。那么，JIT 就不会直接创建 Point 对象，而是直接使用两个标量 int x ，int y 来替代 Point 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">   System.out.println(<span class="string">&quot;point.x=&quot;</span>+x+<span class="string">&quot;; point.y=&quot;</span>+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h6><p>为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><p><strong>但无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><h3 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h3><p>方法区是 Java 虚拟机定义的一种概念，是一种规范；元空间和永久代是其实现</p><ul><li>方法区（Method Area）和 Java 堆一样，是所有线程共享的内存区域</li><li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li><li>运行时常量池是方法区的一部分。Class 文件中除了有类的版本&#x2F;字段&#x2F;方法&#x2F;接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code> 方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</li><li>方法区的大小和堆空间一样，可以固定也可以扩展</li><li>JVM 关闭后方法区会被释放<br>默认值依赖于平台。Windows 下，<code>-XX:MetaspaceSize</code> 是  <code>21M</code> ，<code>-XX:MaxMetaspacaSize</code> 的值是 -1，即没有限制</li></ul><p><font color=blue>方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等</font></p><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p>对每个加载的类型， JVM 必须在方法区中存储以下类型信息</p><ul><li>完整有效名称</li><li>直接父类的完整有效名(对于 interface 或是 java.lang.Object，都没有父类)</li><li>类型的修饰符(public, abstract, final等)</li><li>这个类型直接接口的一个有序列表</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）</p><ul><li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li><li>常量池表是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li></ul><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</p><p>Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p><blockquote><p>jdk1.7 有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</p><p>jdk1.8 取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</p></blockquote><h4 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h4><p>方法区的垃圾回收主要内回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis锁</title>
      <link href="/posts/learn/redis%E9%94%81/"/>
      <url>/posts/learn/redis%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>redis实现锁的机制很复杂，这里主要分析以下</p><h2 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h2><p>该命令来自于 <code>SET if Not Exists</code> 的缩写，意思是如果 <code>key</code> 不存在，则设置 <code>value</code>  ，否则失败返回0</p><p>要释放锁也简单，就是通过 <code>del</code> 删除或者 <code>expire</code> 设置过期时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SETNX lock:168 1  // 获取锁</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EXPIRE lock:168 60  // 60s 自动删除</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>「加锁」和「设置超时」是两个命令，不是 <code>原子操作</code></p><p>于是出现了</p><blockquote><p>SET resource_name random_value NX PX timeout</p></blockquote><p>该命可以在加锁的同时设置过期时间</p><h3 id="释放了不是自己的锁"><a href="#释放了不是自己的锁" class="headerlink" title="释放了不是自己的锁"></a>释放了不是自己的锁</h3><ol><li>客户1获取锁成功设置 30 秒超时</li><li>因为执行很慢，导致锁「自动释放」</li><li>客户2申请加锁成功</li><li>客户1执行完成，执行 <code>DEL</code> 释放了客户2的锁</li></ol><p>要解决这个问题需要从 <code>random_value</code> 下手，在释放锁的时候将自己的「唯一标识」与锁上的「标识」进行比较，匹配上则删除，伪代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 比对 value 与 唯一标识</span><br><span class="line">if (redis.get(&quot;lock&quot;).equals(random_value))&#123;</span><br><span class="line">   redis.del(&quot;lock&quot;); //比对成功则删除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>GET + DEL</code> 命令组合又会涉及到原子问题，通过 <code>LUA</code> 脚本实现</p><h3 id="正确设置锁超时"><a href="#正确设置锁超时" class="headerlink" title="正确设置锁超时"></a>正确设置锁超时</h3><p>锁的超时时间计算，是个很复杂的问题，包括 网络 IO、 JVM Full GC</p><blockquote><p>有没有完美方案？</p></blockquote><p>我们可以让获得锁的线程开启一个守护线程，用来给快要过期的锁「续航」<br>加锁的时候设置一个过期时间，同时客户端开启一个「守护线程」，定时去检测这个锁的失效时间<br><strong>如果快要过期，但是业务逻辑还没执行完成，自动对这个锁进行续期，重新设置过期时间</strong></p><p>Redission 分布式锁的实现，就是基于这种思想，守护线程叫「看门狗」</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><blockquote><p>Redission 类库通过 Redis Hash来实现可重入锁</p></blockquote><p>当线程拥有锁之后，往后再遇到加锁方法，直接将加锁次数加 1，然后再执行方法逻辑<br>退出加锁方法之后，加锁次数再减 1，当加锁次数为 0 时，锁才被真正的释放<br>可以看到可重入锁最大特性就是计数，计算加锁的次数  </p><h4 id="加锁逻辑"><a href="#加锁逻辑" class="headerlink" title="加锁逻辑"></a>加锁逻辑</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---- 1 代表 true</span></span><br><span class="line"><span class="comment">---- 0 代表 false</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>加锁代码首先使用 Redis <code>exists</code> 命令判断当前 lock 是否存在<br>如果不存在，则使用 <code>hincrby</code> 命令创建一个键为 <code>KEYS[1]</code> ，Hash 表中的键为 <code>ARGV[2]</code> ，然后加 1 ，最后设置过期时间<br>如果锁存在，则使用 <code>hexists</code> 判断当前 <code>lock</code> 对应的 hash 表是否存在 <code>KEYS[1] ARGV[2]</code> 这个键，如果存在，再使用 <code>hincrby</code> 加 1 ，最后再设置过期时间</p><h4 id="解锁逻辑"><a href="#解锁逻辑" class="headerlink" title="解锁逻辑"></a>解锁逻辑</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 判断 hash set 可重入 key 的值是否等于 0</span></span><br><span class="line"><span class="comment">-- 如果为 0 代表 该可重入 key 不存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"><span class="comment">-- 计算当前可重入次数</span></span><br><span class="line"><span class="keyword">local</span> counter = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">-1</span>);</span><br><span class="line"><span class="comment">-- 小于等于 0 代表可以解锁</span></span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure><p>解锁逻辑…</p><h2 id="主从架构问题"><a href="#主从架构问题" class="headerlink" title="主从架构问题"></a>主从架构问题</h2><p>之前的分析场景都是锁在「单个」Redis 实例中，并没涉及集群</p><p>Redis 为统一分布式锁标准，搞了一个 Redlock (红锁)</p><h3 id="Red-lock"><a href="#Red-lock" class="headerlink" title="Red lock"></a>Red lock</h3><p>官方推荐部署 5 个以上 Redis 主节点</p><ol><li>客户端获取当前时间 <code>T1</code> (毫秒级别)</li><li>使用相同的 <code>key</code> 和 <code>value</code> 尝试从 <code>N</code> 个 Redis 实例上获取锁</li><li>每个请求都设置一个超时时间(毫秒级别)，改超时时间要远小于锁的有效时间，便于快取获取下一把锁</li><li>客户端获取当前时间 <code>T2</code> 并减去步骤 1 的 <code>T1</code> 计算获取锁的耗时。 <font color=blue>当且仅当客户端在大多数实例（N&#x2F;2 + 1）获取成功，且获取锁所用的总时间 T3 小于锁的有效时间，才认为加锁成功，否则加锁失败</font><ul><li>如果加锁失败，客户端应该在所有的 Redis 实例上进行解锁(<strong>有漏洞</strong>)</li></ul></li></ol><p>缺点：</p><ol><li>red lock 锁场景复杂，且占用资源</li><li>如果在极端情况(多个 redis 实例故障)可能导致锁失效风险</li></ol><h2 id="redission-分布式锁"><a href="#redission-分布式锁" class="headerlink" title="redission 分布式锁"></a>redission 分布式锁</h2><h3 id="失败无限重试"><a href="#失败无限重试" class="headerlink" title="失败无限重试"></a>失败无限重试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 1.最常用的第一种写法</span></span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="comment">// 执行业务逻辑</span></span><br><span class="line">  .....</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿锁失败会不停重试，有 watch dog 自动延期机制，默认续 30s 每隔 30 &#x2F; 3 &#x3D; 10 秒续约到 30 秒</p><h3 id="失败超时重试，自动虚名"><a href="#失败超时重试，自动虚名" class="headerlink" title="失败超时重试，自动虚名"></a>失败超时重试，自动虚名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试拿锁10s后停止重试,获取失败返回false，具有Watch Dog 自动延期机制， 默认续30s</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="超时自动释放锁"><a href="#超时自动释放锁" class="headerlink" title="超时自动释放锁"></a>超时自动释放锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有Watch Dog ，10s后自动释放,不需要调用 unlock 释放锁。</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="超时重试，自动解锁"><a href="#超时重试，自动解锁" class="headerlink" title="超时重试，自动解锁"></a>超时重试，自动解锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁,没有 Watch dog</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Watch-Dog-自动延时"><a href="#Watch-Dog-自动延时" class="headerlink" title="Watch Dog 自动延时"></a>Watch Dog 自动延时</h3><p>Redisson 提供了 watch dog 自动延时机制，提供了一个监控锁的看门狗，它的作用是在 Redisson 实例被关闭前，不断的延长锁的有效期<br>也就是说，如果一个拿到锁的线程一直没有完成逻辑，那么看门狗会帮助线程不断的延长锁超时时间，锁不会因为超时而被释放。</p><p>默认情况下，看门狗的续期时间是 30s，也可以通过修改 <code>Config.lockWatchdogTimeout</code> 来另行指定。</p><p>另外 Redisson 还提供了可以指定 <code>leaseTime</code> 参数的加锁方法来指定加锁的时间。<br>超过这个时间后锁便自动解开了，不会再延长锁的有效期。</p><ul><li>watchdog 只有在未显示指定加锁超时时间(leaseTime)时才会生效</li><li>lockWatchdogTimeout 设定的时间不要太小 ，比如设置的是 100 毫秒，由于网络直接导致加锁完后，watchdog 去延期时，这个 key 在 redis 中已经被删除了。</li></ul><h2 id="Redission源码解读"><a href="#Redission源码解读" class="headerlink" title="Redission源码解读"></a>Redission源码解读</h2><p>在调用 lock 方法时，会链式调用 <code>lock()-&gt;tryAcquire-&gt;tryAcquireAsync</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture;</span><br><span class="line">        <span class="comment">//如果指定了加锁时间，会直接去加锁</span></span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">            ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有指定加锁时间 会先进行加锁，并且默认时间就是 LockWatchdogTimeout的时间</span></span><br><span class="line">            <span class="comment">//这个是异步操作 返回RFuture 类似netty中的future</span></span><br><span class="line">            ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,</span><br><span class="line">                    TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里也是类似netty Future 的addListener，在future内容执行完成后执行</span></span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// leaseTime不为-1时，不会自动延期</span></span><br><span class="line">                <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">                    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//这里是定时执行 当前锁自动延期的动作,leaseTime为-1时，才会自动延期</span></span><br><span class="line">                    scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>scheduleExpirationRenewal</code> 会调用 <code>renewExpiration</code> 启用一个 <code>timeout</code> 定时，去执行延期动作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">        <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager()</span><br><span class="line">          .newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 省略部分代码</span></span><br><span class="line">                ....</span><br><span class="line">                RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">                future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                    ....</span><br><span class="line">                    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                        <span class="comment">//如果 没有报错，就再次定时延期</span></span><br><span class="line">                        <span class="comment">// reschedule itself</span></span><br><span class="line">                        renewExpiration();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cancelExpirationRenewal(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里我们可以看到定时任务 是 lockWatchdogTimeout 的1/3时间去执行 renewExpirationAsync</span></span><br><span class="line">        &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ee.setTimeout(task);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>scheduleExpirationRenewal</code> 会调用 <code>renewExpirationAsync</code> ，执行下面 lua脚本<br>主要判断锁是否存在 redis 中，如果存在旧进行 pexpire 延期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                Collections.singletonList(getRawName()),</span><br><span class="line">                internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>watch dog 在当前节点还存活且任务未完成则每 10 s 给锁续期 30s。</li><li>程序释放锁操作时因为异常没有被执行，那么锁无法被释放，所以释放锁操作一定要放到 finally {} 中；</li><li>要使 watchLog 机制生效 ，lock 时 不要设置 过期时间(leaseTime)。</li><li>watchlog 的延时时间 可以由 lockWatchdogTimeout 指定默认延时时间，但是不要设置太小。</li><li>watchdog 会每 lockWatchdogTimeout&#x2F;3 时间，去延时。</li><li>通过 lua 脚本实现延迟。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis高可用(二)</title>
      <link href="/posts/learn/redis%E9%AB%98%E5%8F%AF%E7%94%A8(%E4%BA%8C)/"/>
      <url>/posts/learn/redis%E9%AB%98%E5%8F%AF%E7%94%A8(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="redis-哨兵机制"><a href="#redis-哨兵机制" class="headerlink" title="redis 哨兵机制"></a>redis 哨兵机制</h1><p>redis 2.8 之后，提供 <code>哨兵(Sentinel) 机制</code> ，实现 <strong>主从节点故障转移</strong>。</p><p>工作原理：监听主节点是否存活，当主节点挂掉，选举从节点担任新的主节点</p><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p>哨兵节点主要负责三件事情：<font color="blue"><strong>监控</strong></font>、<font color="blue"><strong>选主</strong></font>、<font color="blue"><strong>通知</strong></font>。</p><ul><li>哨兵节点如何监控节点？如何判断节点是否故障</li><li>根据什么规则选择从节点切换为主节点</li><li>怎么把新主节点的相关信息通知给从节点和客户端</li></ul><h2 id="如何判断主节点挂了"><a href="#如何判断主节点挂了" class="headerlink" title="如何判断主节点挂了"></a>如何判断主节点挂了</h2><p>哨兵会默认每隔 1 秒给所有节点发送一个 PING 命令，如果没有再规定时间内响应，会标记为 「<font color="blue">主观下线</font>」， 这个「规定时间」配置项 <code>down-after-milliseconds</code> 单位毫秒</p><blockquote><p>主观下线？客观下线？<br>之所以设计「主观下线」和「客观下线」是因为主节点压力较大，就没能及时响应 PING 命令</p></blockquote><p>为了减少误判，哨兵在部署时也会部署成 <font color="blue">哨兵集群( <code>至少三台机器</code> )，通过多个哨兵节点一起判断，就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况</font></p><p>如何判定主节点为「客观下线」？</p><p>当一个哨兵判断主节点为「主观下线」后，会向其他哨兵发起命令，会根据自身和主节点的网络状况，做出赞成投票或拒绝投票<br><img src="/img/learn/sbtp.png" alt="哨兵投票机制"></p><p>当赞成票达到配置文件中 <code>quorum</code> 值后，主节点就会标记为「客观下线」</p><p>PS： quorum 值一般为哨兵个数的一半 + 1，(1&#x2F;2 + 1)</p><h2 id="由哪个哨兵进行主从故障转移"><a href="#由哪个哨兵进行主从故障转移" class="headerlink" title="由哪个哨兵进行主从故障转移"></a>由哪个哨兵进行主从故障转移</h2><p>哨兵集群中需要一个 Leader ，让 Leader 来执行主从切换</p><p>选举 leader 哨兵的过程是一个投票过程，在投票开始前，有一个「候选者」</p><blockquote><p>候选者是谁？</p></blockquote><p>哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选 Leader</p><blockquote><p>候选者如何选举成 Leader?</p></blockquote><p>候选者向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票</p><p>任何一个「候选者」，成为 Leader 要满足两个条件：</p><ul><li>第一，拿到半数以上的赞成票</li><li>第二，拿到的票数同时还需要大于等于(&gt;&#x3D;)哨兵配置文件中的 quorum 值</li></ul><p>如果某个时间点，有多个哨兵节点判断到主节点为「客观下线」，那么候选者会投自己，其余哨兵节点会投给 <font color="blue">先收到「候选者」的投票请求</font> </p><h2 id="主从故障转移的过程"><a href="#主从故障转移的过程" class="headerlink" title="主从故障转移的过程"></a>主从故障转移的过程</h2><p>主从故障转移操作包含以下四个步骤</p><ul><li>第一步，在已下线主节点(旧主节点)中所有「从节点」里，选一个转换为主节点</li><li>第二步，让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」</li><li>第三步，将新主节点的 IP 地址和信息，同步 「发布者&#x2F;订阅者机制」通知给客户端</li><li>第四步，继续监视旧主节点，当这个旧主节点上线时，将它设置为主节点的从节点</li></ul><h3 id="1-选出新主节点"><a href="#1-选出新主节点" class="headerlink" title="1.选出新主节点"></a>1.选出新主节点</h3><p>挑选出一个状态良好、数据完整的从节点为「新主节点」并发送 SLAVEOF no one 命令，将这个「从节点」转换为「主节点」</p><p>筛选过滤方式：</p><ol><li>首先通过网络连接状态过滤，redis中有个 <code>down-after-milliseconds * 10</code> ，是主从节点断连的最大连接超时时间，如果超过这个时间，并且发生断连的次数超过 10 次，那么就认为这个节点网络不好，就过滤掉</li></ol><p>之后就进行比较 <font color="blue">优先级、复制进度、ID 号</font></p><ul><li>第一轮考察，根据从节点的优先级进行排序，优先级越小排名越靠前</li><li>二，如果优先级相同，则查看复制的下标，哪个从「主节点」接收的复制数据多，哪个就靠前。</li><li>三，如果优先级和下标都相同，就选择从节点 ID 较小的那个</li></ul><p>优先级： slave-priority 配置项，可以给从节点设置优先级<br>复制进度：用 offset进行比较<br>ID 号小的从节点胜出：比较两个节点 ID</p><p>总结<br><img src="/img/learn/zc.png" alt="选出新节点"></p><h3 id="2-将从节点指向新主节点"><a href="#2-将从节点指向新主节点" class="headerlink" title="2.将从节点指向新主节点"></a>2.将从节点指向新主节点</h3><p>让已下线主节点属下「从节点」指向「新主节点」，这一动作可以通过向「从节点」<br>发送 <code>SLAVEOF</code> 命令实现</p><h3 id="3-通知客户"><a href="#3-通知客户" class="headerlink" title="3.通知客户"></a>3.通知客户</h3><p>通过 <font color="blue">发布者&#x2F;订阅者机制</font>实现通知客户端</p><p>主从切换完成后，哨兵向 <code>+switch-master</code> 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里的新主节点的 IP 地址和端口进行通信</p><p><img src="/img/learn/zcqh.png" alt="主从切换通知"></p><h3 id="4-监视旧主节点"><a href="#4-监视旧主节点" class="headerlink" title="4.监视旧主节点"></a>4.监视旧主节点</h3><p>继续监视旧主节点，当就主节点上线后，哨兵集群发送 <code>SLAVEOF</code> 命令，成为新主节点的从节点</p><h2 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h2><p>搭建哨兵集群只需要配置几个参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置主节点、主节点的 IP 地址和端口号以及 quorum 值</span></span><br><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure><p><font color="blue">哨兵节点之间通过 Redis 的发布者&#x2F;订阅者机制来相互发现</font></p><p>主节点上有一个名为 <code>__sentinel__:hello</code> 的频道，不同哨兵通过它来相互发现，订阅其频道，然后发送自己的 IP 地址和端口实现相互发现建立连接</p><blockquote><p>哨兵如何监控从节点信息<br>哨兵会每 10 秒一次的频率向主节点发送 INFO 命令获取所有「从节点」的信息，并与从节点建立连接</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis高可用(一)</title>
      <link href="/posts/learn/redis%E9%AB%98%E5%8F%AF%E7%94%A8(%E4%B8%80)/"/>
      <url>/posts/learn/redis%E9%AB%98%E5%8F%AF%E7%94%A8(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="redis-集群"><a href="#redis-集群" class="headerlink" title="redis 集群"></a>redis 集群</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>为了避免单点故障，redis提供了 <code>主从复制功能</code></p><p>保证服务器 数据一致性，且主从服务器之间采用 「读写分离」 方式<br><img src="/img/learn/dxfl.png" alt="读写分离"></p><h3 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h3><p>使用 <code>replicaof</code> 命令形成主服务器和从服务器关系</p><p>比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务器 B 执行这条命令，成为 A 的从服务器</span></span><br><span class="line">replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 redis 端口号&gt;</span><br></pre></td></tr></table></figure><p>主从服务器第一次同步过程分为三个阶段</p><ul><li>建立连接、协商同步</li><li>主服务器同步数据给从服务器</li><li>主服务器发送新写操作命令给从服务器</li></ul><h4 id="建立连接、协商同步"><a href="#建立连接、协商同步" class="headerlink" title="建立连接、协商同步"></a>建立连接、协商同步</h4><p>执行了 <code>replicaof</code> 后，从服务器会给主服务器发送 <code>psync</code> 命令，表示数据同步</p><p>psync 命令包含两个参数， <strong>主服务器的 runID</strong> 和 <strong>复制进度 offset</strong></p><ul><li>runID，每个redis在启动时会产生一个随机的ID用来唯一标识自己</li><li>offset，表示复制进度，第一次同步时，值为 -1</li></ul><p>主服务器收到 psync 命令后，会用 <code>FULLRESYNC</code> 作为响应返回给对方</p><p>FULLRESYNC 也携带两个参数： 主进程的 runID 和 主服务器目前的复制进度 offset</p><p>FULLRESYNC 响应命令 采用 <strong>全量复制</strong> 的方式</p><h4 id="主服务器同步数据给从服务器"><a href="#主服务器同步数据给从服务器" class="headerlink" title="主服务器同步数据给从服务器"></a>主服务器同步数据给从服务器</h4><p>主服务器会执行 bgsave 来生成 RDB 文件，然后把文件发送给从服务器</p><p>从服务器收到 RDB 文件后，会清空数据库，然后载入 RDB 文件</p><p>这里在主服务器上执行 bgsave 的期间，如果执行写操作，记录不会记录到刚刚生成的 RDB 文件中，这时主从服务器间数据不一致</p><p>为了保证主从服务器数据一致性， <strong>主服务器在下面这三个时间间隙收到的写操作命令，写入到 replication buffer 缓冲区</strong></p><ul><li>主服务器生成 RDB 文件期间</li><li>主服务器发送 RDB 文件给从服务器期间</li><li>「从服务器」加载 RDB 文件期间</li></ul><h4 id="主服务器发送新写操作命令给从服务器"><a href="#主服务器发送新写操作命令给从服务器" class="headerlink" title="主服务器发送新写操作命令给从服务器"></a>主服务器发送新写操作命令给从服务器</h4><p>完成 RDB 的载入后，从服务器会回复一个确认消息给主服务器</p><p>接着主服务器将 replication buffer 缓冲区中读取命令，发送给从服务器，来保证数据一致性</p><h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>主从服务器在完成第一次同步后，双方维护一个 <strong>TCP 长连接</strong></p><p>后续主服务器通过连接将写操作命令发送给从服务器，维持数据一致性</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>当主从服务器连接断开，客户端可能从 「从服务器」读到旧数据</p><p>如果此时断开的网络，又恢复正常，如何保证主从服务器数据一致性</p><p>redis 2.8 之前，会进行全量复制，即重新执行一次主从服务器第一次同步过程</p><p>redis 2.8 开始，主从服务器采用 <strong>增量复制</strong> 的方式继续同步，三个步骤</p><ul><li>恢复连接后，从服务器发送 psync 给主服务器，此时 offset 不为 -1</li><li>主服务器收到命令后，用 CONTINUE 响应，采用增量复制的方式同步数据</li><li>主服务器从主从服务器断开期间，所执行的写命令发送给从服务器执行</li></ul><p><strong>主服务器怎么知道要将哪些增量数据发送给从服务器？</strong></p><ul><li><code>repli_backlog_buffer</code> 是一个 「<strong>环形</strong>」缓冲区</li><li><code>replication offset</code> 标记上面那个缓冲区的同步进度，主从服务器有各自的偏移量，主服务器使用 master_repl_offset 标记自己的「写」，从服务器使用 slave_repl_offset 来标记自己「读」到的位置</li></ul><p>在主服务器进行命令传播时，会将写命令发送给从服务器，也会写入到 repli_backlog_buffer 缓冲区中</p><p>重连后，从服务器将自己的偏移量 offset 发送给主服务器</p><ul><li>如果偏移量在 repl_backlog_buffer 缓冲区里，采用 <strong>增量复制</strong></li><li>如果不在，则采用 <strong>全量同步</strong></li></ul><p>为避免频繁使用全量同步，应该调整 <code>repl-backlog-size</code> 参数，默认为 1M</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过命令修改</span></span><br><span class="line">CONFIG SET repl-backlog-size 2mb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过配置文件修改</span></span><br><span class="line">repl-backlog-size 2mb</span><br></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="如何判断-redis-某个节点是否正常工作"><a href="#如何判断-redis-某个节点是否正常工作" class="headerlink" title="如何判断 redis 某个节点是否正常工作"></a>如何判断 redis 某个节点是否正常工作</h3><p>主节点每隔 10 秒</p><p>从节点每隔 1 秒</p><h3 id="主从复制架构中，过期-key-如何处理"><a href="#主从复制架构中，过期-key-如何处理" class="headerlink" title="主从复制架构中，过期 key 如何处理"></a>主从复制架构中，过期 key 如何处理</h3><h3 id="redis-是同步复制还是异步复制"><a href="#redis-是同步复制还是异步复制" class="headerlink" title="redis 是同步复制还是异步复制"></a>redis 是同步复制还是异步复制</h3><h3 id="主从复制中两个-Buffer-replication-buffer-和-repl-backlog-size-有什么区别"><a href="#主从复制中两个-Buffer-replication-buffer-和-repl-backlog-size-有什么区别" class="headerlink" title="主从复制中两个 Buffer(replication buffer 和 repl-backlog-size)有什么区别"></a>主从复制中两个 Buffer(replication buffer 和 repl-backlog-size)有什么区别</h3><h3 id="如何应对主从数据不一致"><a href="#如何应对主从数据不一致" class="headerlink" title="如何应对主从数据不一致"></a>如何应对主从数据不一致</h3><blockquote><p>为什么会出现主从不一致？</p></blockquote><blockquote><p>如何应对主从不一致</p></blockquote><h3 id="主从切换如何减少数据丢失"><a href="#主从切换如何减少数据丢失" class="headerlink" title="主从切换如何减少数据丢失"></a>主从切换如何减少数据丢失</h3><p>主从切换，产生数据丢失的情况有两种</p><ul><li>异步复制同步丢失</li><li>集群产生脑裂数据丢失</li></ul><p>我们不可能保证数据完全不丢失，只能做到使得尽量少的数据丢失</p><h4 id="异步复制同步丢失"><a href="#异步复制同步丢失" class="headerlink" title="异步复制同步丢失"></a>异步复制同步丢失</h4><p>对于 redis 主节点与从节点之间的数据复制，是「异步复制」的，当客户端发送写请求给主节点，客户端会返回 ok ，主节点将写请求 异步 同步给各个从节点，但如果主节点还没来得及同步发生了断电，主节点内存的数据会丢失</p><blockquote><p>减少异步复制的数据丢失方案</p></blockquote><p>redis 配置中 <code>min-slaves-max-lag</code> ，表示一旦所有从节点数据复制和同步的延迟超过了 min-slaves-max-lag 值，主节点就会停止接受写请求，直到所有从节点数据同步完成</p><p>假设将 min-slaves-max-lag 设置为 5，那么当所有从节点数据复制和同步的延迟都超过 5 秒，就会认为 master 未来宕机后损失的数据会很多，拒绝写入新请求，这样 master 和 slave 数据差控制在 5 秒内，可以减少数据丢失</p><p>对于客户端，当发现不可写后，可以降级处理，先将数据写入本地缓存和磁盘，等恢复后再写入 master ；也可以写入消息队列，隔一段时间消费消息，重新写入</p><h4 id="集群产生脑裂数据丢失"><a href="#集群产生脑裂数据丢失" class="headerlink" title="集群产生脑裂数据丢失"></a>集群产生脑裂数据丢失</h4><p>由于网络波动，集群节点间失去联系，主从数据不同步；重新选举主节点，将原来的主节点数据清空作为从节点，这导致原来的主节点的「断开期间的写操作」数据丢失</p><blockquote><p>减少脑裂数据丢失</p></blockquote><ul><li>min-slaves-to-write x，主节点必须 <strong>至少 x 个从节点连接</strong>，否则禁止写数据</li><li>min-slaves-max-lag x，数据复制和同步的延迟 <strong>不能超过 x 秒</strong>，否则禁止写入</li></ul><h3 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h3><p>redis 哨兵机制…</p>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/posts/learn/redis/"/>
      <url>/posts/learn/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis 相关点</p><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><ol><li>String(字符串)</li><li>List(列表)</li><li>Hash(键-值)</li><li>Set(无序集合)</li><li>ZSet(有序集合)</li></ol><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String-字符串"></a>String-字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 key-value 类型的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET name lin</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 key 获得对应的 value</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET name</span></span><br><span class="line">&quot;lin&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断某个 key 是否存在</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EXISTS name</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回 key 所储存的字符串值的长度</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">STRLEN name</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某个 key 对应的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">DEL name</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量设置 key-value 类型的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">MSET key1 value1 key2 value2</span> </span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量获取多个 key 对应的 value</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">MGET key1 key2</span> </span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用场景</span></span><br><span class="line">- setnx简单的分布式锁</span><br><span class="line">- 记录用户登录</span><br><span class="line">- 常规计数</span><br></pre></td></tr></table></figure><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List-列表"></a>List-列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">LPUSH key value [value ...]</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表尾(最右边)</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">RPUSH key value [value ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的头元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">LPOP key</span>     </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的尾元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">RPOP key</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">LRANGE key start stop</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表头弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">BLPOP key [key ...] <span class="built_in">timeout</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表尾弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">BRPOP key [key ...] <span class="built_in">timeout</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">应用场景</span></span><br><span class="line">// 可以当作简单的 `消息队列`  </span><br></pre></td></tr></table></figure><h3 id="Hash-键值对"><a href="#Hash-键值对" class="headerlink" title="Hash-键值对"></a>Hash-键值对</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储一个哈希表key的键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HSET key field value</span>   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表key对应的field键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HGET key field</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在一个哈希表key中存储多个键值对</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HMSET key field value [field value...]</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量获取哈希表key中多个field键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HMGET key field [field ...]</span>       </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除哈希表key中的field键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HDEL key field [field ...]</span>    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回哈希表key中field的数量</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HLEN key</span>       </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回哈希表key中所有的键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HGETALL key</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为哈希表key中field键的值加上增量n</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HINCRBY key field n</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用场景</span>  </span><br><span class="line">可以缓存对象信息、用户购物车</span><br></pre></td></tr></table></figure><h3 id="Set-无序键值集合"><a href="#Set-无序键值集合" class="headerlink" title="Set-无序键值集合"></a>Set-无序键值集合</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往集合key中存入元素，元素存在则忽略，若key不存在则新建</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD key member [member ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中删除元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SREM key member [member ...]</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取集合key中所有元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SMEMBERS key</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取集合key中的元素个数</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SCARD key</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断member元素是否存在于集合key中</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER key member</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中随机选出count个元素，元素不从key中删除</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER key [count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中随机选出count个元素，元素从key中删除</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP key [count]</span></span><br><span class="line">Set运算操作：</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交集运算</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SINTER key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将交集结果存入新集合destination中</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SINTERSTORE destination key [key ...]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并集运算</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SUNION key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将并集结果存入新集合destination中</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SUNIONSTORE destination key [key ...]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">差集运算</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SDIFF key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将差集结果存入新集合destination中</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SDIFFSTORE destination key [key ...]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用场景</span>  </span><br><span class="line">- Set 类型可以保证一个用户只能点一个赞  </span><br><span class="line">- 共同关注  </span><br><span class="line">- 抽奖活动</span><br></pre></td></tr></table></figure><h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset-有序集合"></a>Zset-有序集合</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往有序集合key中加入带分值元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD key score member [[score member]...]</span>   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往有序集合key中删除元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZREM key member [member...]</span>                 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回有序集合key中元素member的分值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZSCORE key member</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回有序集合key中元素个数</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZCARD key</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为有序集合key中元素member的分值加上increment</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZINCRBY key increment member</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">倒序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZREVRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回有序集合中指定分数区间内的成员，分数由低到高排序。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX key min max [LIMIT offset count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZREVRANGEBYLEX key max min [LIMIT offset count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZUNIONSTORE destkey numberkeys key [key...]</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZINTERSTORE destkey numberkeys key [key...]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用场景</span>  </span><br><span class="line">- 排行榜  </span><br><span class="line">- 电话姓名排序</span><br></pre></td></tr></table></figure><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis持久化方式</p><ol><li>AOF日志(快照 + 追加命令)</li><li>RDB快照(二进制文件)</li></ol><h3 id="AOF日志-Appen-Only-File"><a href="#AOF日志-Appen-Only-File" class="headerlink" title="AOF日志 (Appen Only File)"></a>AOF日志 (Appen Only File)</h3><p>AOF 只会记录 <code>写操作</code> ，读操作不会被记录，因为没意义</p><h4 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h4><p>如果每次修改都写入磁盘，会造成极大的资源浪费，所以redis 创建了 <code>AOF 缓冲区</code>，并提供了三种写回策略：</p><ul><li><code>Always</code> ，每次执行完写操作，同步 AOF 日志数据回硬盘</li><li><code>Everysec</code> ，每次执行完写操作，先将命令写到 AOF 内核缓冲区，每秒将缓冲区里内容写回硬盘</li><li><code>No</code> ，将写回时机交给操作系统决定</li></ul><p>这三种策略知识在控制 <code>fsync()</code> 函数调用时机</p><h4 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h4><p>为了避免 AOF 文件越写越大，提供了 <code>AOF 重写机制</code></p><p>AOF 重写机制是在重写时，读取当前数据库中所有键值对记录到[新的 AOF 文件] ，然后将新的 AOF 文件替换旧的 AOF 文件，从而实现 AOF 文件的压缩。</p><p><code>为何用新文件替换旧文件？</code> 这样确保如果重写失败了，也不会对现有 AOF 文件造成污染。</p><p>AOF 重写过程由后台子进程 <code>bgrewriteaof</code> 来完成</p><p>主进程会复制一份 <code>[页表](记录虚拟地址与物理地址映射关系) 给子进程</code> ，这样做 <code>节约物理内存资源</code></p><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>当父进程或子进程对内存发起写操作时， CPU 会触发 <code>写保护中断</code> ，操作系统会进行 <code>物理内存复制</code>，并重新设置映射关系，将父进程的内存读写权限设置为 <code>可读写</code>，最后才对内存进行写操作，这个过程叫 <code>写时复制(Copy On Write)</code></p><p>主进程修改已经存在的 key-value ，就会发生 写时复制 ， <code>只会复制主进程修改的物理内存数据，没修改的内存还是与子进程共享</code> </p><p>为了解决 <code>写时复制主线程修改的值与 AOF 文件中数据不一致问题</code>， redis 设置了 <code>AOF 重写缓冲区</code></p><p>当重写 AOF 期间，当 redis 执行完一个写命令，会 <code>同时将这个命令写到 [AOF 缓冲区] 和 [AOF 重写缓冲区]</code></p><p>当子进程完成 AOF 重写工作后，会向主进程发送一条信号，主进程收到信号会做以下事情</p><ul><li>将 AOF 重写缓冲区的数据写入 AOF 文件</li><li>覆盖原有 AOF 文件</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>AOF 记录的写操作命令， RDB记录的是某一瞬间的数据快照</p><p>因此在进行数据恢复时， RDB 优于 AOF</p><h4 id="RDB-生成时机"><a href="#RDB-生成时机" class="headerlink" title="RDB 生成时机"></a>RDB 生成时机</h4><p>RDB 提供 <code>save</code> 和 <code>bgsave</code>，区别在于是否在[主线程执行]</p><p>RDB通过配置文件来实现每隔一段时间自动执行一次 bgsave 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br></pre></td></tr></table></figure><p>选项名叫save ，实际执行的是 bgsave</p><ul><li>900 秒内，对数据库进行了至少 1 次修改</li><li>300 秒内，对数据库至少进行了 10 次修改</li></ul><p>注： <code>RDB 快照是全量快照</code></p><h4 id="RDB-的写时复制"><a href="#RDB-的写时复制" class="headerlink" title="RDB 的写时复制"></a>RDB 的写时复制</h4><p>当在进行 bgsave 时，主进程依旧能 <code>继续处理操作命令</code></p><p>如果这时主线程要 <code>修改共享数据里的某一块数据</code> (如 A)，就会发生写时复制，这块数据的 <code>物理内存会被复制一份(A·)</code> ，然后 <code>主线程操作数据副本(A·)</code> ，此时 <code>bgsave 子进程可以继续把原来的数据(A) 写入到 RDB 文件中</code></p><p>注意，<code>发生写时复制时， RDB 快照保存的是原本的内存数据</code> ，而修改的数据是没办法写入本次 RDB 文件的， <code>主线程刚修改的数据交由下次处理</code></p><h3 id="aof-use-rdb-preamble-yes"><a href="#aof-use-rdb-preamble-yes" class="headerlink" title="aof-use-rdb-preamble yes"></a>aof-use-rdb-preamble yes</h3><p>混合使用 AOF 和 RDB ，进行 混合持久化</p><p><code>前半部分是 RDB 的全量数据，后半部本是 AOF 格式的增量数据</code></p><p>这样 <code>加载的时候速度会很快</code></p><p>并且 加载完 RDB 内容后，才会加载后半部分的 AOF 内容， 这里的内容是 redis 后台子进程重写 AOF 期间，主线程处理的操作命令，使 <code>数据丢失更少</code></p><h2 id="过期删除策略和内存淘汰策略"><a href="#过期删除策略和内存淘汰策略" class="headerlink" title="过期删除策略和内存淘汰策略"></a>过期删除策略和内存淘汰策略</h2><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>redis 可以对 key 设置过期时间，相对应的机制将过期的键值对删除，这个机制就是过期键值删除策略</p><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><p>一般使用 <code>expire &lt;key&gt; &lt;n&gt;</code> ， 表示 key 在 n 秒后过期</p><p>也可以在创建时对 key 设置过期时间 <code>set &lt;key&gt; &lt;value&gt; ex &lt;n&gt; </code> 或 <code>setex &lt;key&gt; &lt;n&gt; &lt;value&gt;</code> ，表示设置键值对时，同时设置过期时间(单位 <code>秒</code> )</p><p>如果想查看某个 key 剩余存活时间，可以使用 <code>TTL &lt;key&gt;</code> 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置键值对，同时指定过期时间 60 秒</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">setex key1 60 value1</span></span><br><span class="line">ok</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 key1 过期时间</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ttl key1</span></span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure><p>如果反悔，取消 key 的过期时间，可以用 <code>persist &lt;key&gt;</code> 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消 key1 的过期时间</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">persist key1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 key1 过期时间</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-1 则表明永不过期</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ttl key1</span></span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><h4 id="Redis-如何判定过期"><a href="#Redis-如何判定过期" class="headerlink" title="Redis 如何判定过期"></a>Redis 如何判定过期</h4><p>当我们设置过期时间时， redis 会把该 key 带上过期时间存储到一个 <code>过期字典</code> 里<br>(实际上时 哈希表 ，时间复杂度 O(1))</p><h4 id="过期删除策略-1"><a href="#过期删除策略-1" class="headerlink" title="过期删除策略"></a>过期删除策略</h4><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><p>定期删除： <code>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达，由该事件处理器自动执行 key 的删除</code></p><p>惰性删除： <code>不主动删除过期 key ， 每次从数据库访问时进行检测，如果过期则删除 key</code></p><p>定时删除： <code>每隔一段时间 [随机(默认20个)] 从数据库取出一定量的 key 进行检查，并删除其中的 过期 key</code></p><h4 id="redis-过期删除策略"><a href="#redis-过期删除策略" class="headerlink" title="redis 过期删除策略"></a>redis 过期删除策略</h4><p>Redis 选择 <code>[惰性删除 + 定期删除]</code> 配合使用</p><p>惰性删除：  对访问的 key 判断是否过期，如果过期删除 key ，并且返回 null</p><p>定期删除： redis 默认每秒进行 10 次过期检查，通过 <code>redis.conf.hz</code> 进行设置；默认每次抽取 20 个 key，检查并删除过期的 key；如果本轮过期的数量超过 25% ，则重复执行，直至过期的 key 小于 25%，则停止继续删除过期 key ， 等待下一轮检查</p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>过期删除策略是删除过期的 key ，而 Redis 内存淘汰策略是 <code>当 Redis 运行内存超过 Redis 设置的最大内存后，用内存淘汰策略删除符合条件的 key</code> ， 以此来保障 Redis 高效运行</p><h4 id="如何设置-Redis-最大运行内存"><a href="#如何设置-Redis-最大运行内存" class="headerlink" title="如何设置 Redis 最大运行内存"></a>如何设置 Redis 最大运行内存</h4><p>在 redis.conf 中，通过参数 <code>maxmemory &lt;bytes&gt;</code> 来设置</p><ul><li>在 64 位操作系统中，这个默认值为 <code>0</code> ，表示没有内存大小限制</li><li>在 32 位操作系统中，这个默认值为 <code>3GB</code>，因为 32 位的机器最大支持 4GB 内存</li></ul><h4 id="Redis-内存淘汰策略"><a href="#Redis-内存淘汰策略" class="headerlink" title="Redis 内存淘汰策略"></a>Redis 内存淘汰策略</h4><ol><li>不进行数据淘汰策略<ul><li>noevication(redis3.0后， <code>默认的内存淘汰策略</code>)：不进行数据淘汰，拒绝写入</li></ul></li><li>进行数据淘汰<ul><li>volatile-random：随机淘汰，只淘汰设置了 <code>expire</code> 的 key</li><li>volatile-ttl：优先淘汰更早过期的 key</li><li>volatile-lru：淘汰所有设置了过期时间中，最久未使用的 key</li><li>volatile-lfu：淘汰所有设置了过期时间中，最少使用的 key</li><li>allkeys-random：随机淘汰</li><li>allkeys-lru：淘汰整个 key 中最久未使用的</li><li>allkeys-lfu：淘汰整个 key 中最少使用的</li></ul></li></ol><p>使用 <code>config get maxmemory-policy</code> 查看当前内存淘汰策略</p><p>设置内存淘汰策略方式</p><ol><li>通过命令 <code>config set maxmemory-policy &lt;策略&gt;</code> 设置</li><li>通过 redis.conf 设置 <code>maxmemory-policy &lt;策略&gt;</code></li></ol><h4 id="LRU-和-LFU"><a href="#LRU-和-LFU" class="headerlink" title="LRU 和 LFU"></a>LRU 和 LFU</h4><p>LRU：Least Recently Used， <code>最久未使用</code> ， 维护一个额外字段，记录此数据最后一次访问时间； <code>无法解决缓存污染</code></p><p>LFU：Least Frequently Used，<code>使用频率最少</code> ，记录使用次数</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><code>布隆过滤器(Bloom Filter)</code> 是一种空间效率高的概率数据结构，用于快速判断一个元素是否再一个集合中</p><p>布隆过滤器遵循 <code>存在的不一定存在，不存在的一定不存在</code></p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><code>一个位数组和多个哈希函数来实现</code> 。</p><p>流程</p><ol><li>初始化  <ol><li>创建一个大小为m大小的 <code>位数组</code></li><li>对要添加的元素使用 <code>k</code> 个哈希函数分别计算，得到 <code>k</code> 个哈希值。</li></ol></li><li>将这 <code>k</code> 个哈希值对应到位数组中的位置，并将这些位置设置为 <code>1</code>。</li><li>查询元素，对要检查的元素分别进行哈希，然后 <code>将哈希值对应位置与位数组进行比较</code>，如果对应位置都为1，则表示 <code>该元素可能</code> 存在</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>空间效率高</li><li>查询速度快</li><li>简单易用</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><code>误判</code></li><li><code>无法删除元素</code></li><li>需要合理选择参数</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>todo </p>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网</title>
      <link href="/posts/learn/%E8%AE%A1%E7%BD%91/"/>
      <url>/posts/learn/%E8%AE%A1%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>相关点</p><h2 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h2><ol><li><p>应用层(application)<br> 最上层，应用软件都在应用层实现。<br> 应用层 <code>专注于为用户提供应用功能</code> ，比如 <code>HTTP</code> 、 <code>DNS</code>等</p></li><li><p>传输层(Transport)<br> 传输层有两个协议：<code>TCP</code> 和 <code>UDP</code><br> <code>TCP</code> 的全程叫 传输控制协议(Transmission Control Protocol) ， 大部分使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。 TCP比UDP多了很多特性，比如 <code>可靠传输</code> 、 <code>流量控制</code> 、 <code>拥塞控制</code> 等。</p><p> <code>UDP</code> 的全称叫 用户数据包协议(User Datagram Protocol)。 UDP简单到 <code>只负责发送数据包，不保证是否抵达</code>。但实时性相对更好，传续效率高。 <code>UDP也可以实现可靠传输，把 TCP 达到特性在应用层实现</code>。</p></li></ol><p>应用层传输的数据可能很大，如果直接传输就不好控制，因此当传输层的数据包大小超过 <code>MSS(TCP最大保本段长度)</code> ，就要将数据包分块，这样即使途中有数据包丢失，只需要重新传送这一个分块。在 TCP 协议中，每个分块成为一个 <code>TCP段(TCP Segment)</code> </p><p><code>传输层携带端口，识别该报文发送给哪个应用</code></p><ol start="3"><li>网络层(Network)<br>网络层负责<code>实际的传输功能</code><br>网络层最常使用的 <code>IP 协议</code> ，IP 协议将传输层的报文作为数据部分，加上 <code>IP包头</code> 组成 IP 报文，如果 IP 报文大小超过 <code>MTU(一般为1500字节)</code> 就会再次进行 <code>分片</code> ，得到一个即将发送到网络的 IP 报文。</li></ol><p><code>IP协议的寻址作用告诉我们去往下一个目的地该朝哪个方向走，路由则是根据[下一个目的地]选择路径。寻址更像导航，路由更像操作方向盘</code></p><ol start="4"><li>网络接口层(Link)<br>在接收到 IP 报文后，交给 网络接口层在 IP 头部的前面加上 MAC 头部，并封装成 <code>数据帧</code> 发送到网络。<br>MAC 头部是以太网使用的额头不，包含接收方和发送方的 MAC地址等信息。通过 ARP 协议获取对方的 MAC 地址。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>应用层：负责向用户提供应用程序</li><li>传输层：对应用层数据进行分组和重组，并以TCP或UDP协议格式封装报文。</li><li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li><li>链路层：负责封装和解封 IP 报文，发送和接收ARP&#x2F;RARP报文等。</li></ul><p>OSI七层模型为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。由于复杂并没有广泛使用。</p><h2 id="键入网址流程"><a href="#键入网址流程" class="headerlink" title="键入网址流程"></a>键入网址流程</h2><p>todo…</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 是超文本传输协议，也就是<code>H</code> yper <code>T</code> ext <code>T</code> ransfer <code>P</code> rotocol</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>1xx：提示信息，表示正在处理</li><li>2xx：成功</li><li>3xx：重定向</li><li>4xx：客户端错误</li><li>5xx：服务器错误</li></ul><h3 id="HTTP-常见字段"><a href="#HTTP-常见字段" class="headerlink" title="HTTP 常见字段"></a>HTTP 常见字段</h3><ul><li><code>Host</code> 字段：用来指定服务器域名</li><li><code>Content-Type</code> 字段：用来指定请求或响应的数据类型</li><li><code>Connection</code> 字段：用来指定是否为长连接</li></ul><h3 id="GET-和-POST"><a href="#GET-和-POST" class="headerlink" title="GET 和 POST"></a>GET 和 POST</h3><ul><li><code>GET 方法就是安全且幂等的</code> ， 因为它是 [只读] 操作， <code>可以对 GET 请求的数据做缓存，可以做到服务器本身上，也可以做到代理上(如Nginx)，而且在浏览器中 GET请求可以保存为书签。</code></li><li><code>POST</code> 因为要提交数据，所以是 <code>不安全的</code> ，且多次提交数据就会创建多个资源，所以不是 <code>幂等</code> 的。 <code>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</code>。</li></ul><h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p>对于一些具有重复性的请求，可以对 [请求-响应] 的数据都 <code>缓存在本地</code>，那么下次直接读取，不必获取服务器响应。</p><p>缓存实现方式：<code>强制缓存</code> 和 <code>协商缓存</code>。</p><ul><li>强制缓存：服务器在响应头中设置 <code>Cache-Control</code> 字段，设置 <code>max-age</code> 或者 <code>Expires</code> 字段，浏览器会根据这些字段判断是否需要缓存。</li><li>协商缓存：基于 <code>时间</code> 或 <code>标识</code> 来实现。 服务器在响应头中设置 <code>Last-Modified(这个相应资源的最后修改时间)</code> 或者 <code>Etag(唯一标识响应资源)</code> 字段，浏览器会根据这些字段判断是否需要缓存。 如果两个字段都有， <code>Etag</code> 的优先级更高。<br>注：<code>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</code></li></ul><h3 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h3><p>HTTP&#x2F;1.1<br><code>无状态</code> 和 <code>明文传输</code> 既是优点也是缺点</p><ul><li><code>无状态</code> 表明服务器不会保存客户端的状态，服务器资源能利用更加高效。但缺点就是服务器没有记忆能力，<code>每次请求都需要对身份进行确认。</code></li><li><code>明文传输</code> 方便阅读，方便进行调试，但缺点是安全性低。</li></ul><p>HTTP 的安全问题，可以用 HTTPS 的方式解决，通过引入 <code>SSL/TLS</code> 层使得在安全上达到了极致。</p><h3 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h3><p> HTTP 基于 <code>TCP/IP</code> ，并且使用了 [请求-应答] 的通信模式，所以性能的关键在于：</p><ul><li>长连接<br>HTTP&#x2F;1.0 默认不支持长连接，每一次请求都要新建 TCP连接，性能差，而 HTTP&#x2F;1.1 提出了长连接， <code>减少了重复简历连接的开销</code></li><li>管道网络传输<br>HTTP&#x2F;1.1 默认支持管道网络传输， <code>可以同时发送多个请求，减少请求等待时间。但服务器必须按照接收请求的顺序发送对这些管道请求的响应</code><br>这就有个问题： <code>HTTP/1.1解决了请求的队头阻塞，但是没有解决响应的对头阻塞</code>。</li></ul><h3 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h3><ul><li>HTTP 是超文本传输协议，信息明文传输，不安全。HTTPS 是 HTTP 的安全版本，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文加密传输。</li><li>HTTP建立连接相对简单， TCP 三次握手就可以；而 HTTPS 还需要进行 SSL&#x2F;TLS 的握手过程。</li><li>HTTP 默认端口 <code>80</code> ， HTTPS 默认端口 <code>443</code>。</li><li>HTTPS协议要向 CA(证书权威机构) 申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="HTTPS-解决-HTTP-风险"><a href="#HTTPS-解决-HTTP-风险" class="headerlink" title="HTTPS 解决 HTTP 风险"></a>HTTPS 解决 HTTP 风险</h3><ul><li>信息加密: 交互信息无法窃取</li><li>校验机制: 无法篡改通信内容</li><li>身份证书: 服务器端证书，证明真伪</li></ul><p>解决方法</p><ul><li><code>混合加密</code> 实现信息的 <code>机密性</code></li><li><code>摘要算法</code> 实现完整性，为数据生成独一无二的 [指纹] ，用来校验数据完整性</li><li>将服务器公钥放入 <code>数字证书</code> 解决冒充</li></ul><ol><li><code>混合加密</code></li></ol><p>HTTPS 采用 <code>对称加密</code> 和 <code>非对称加密</code> 结合的 [混合加密]</p><ul><li>在通信建立前采用 <code>非对称加密</code> 交换 [会话密钥] ，后续不再使用非对称加密</li><li>在通信过程中全部使用 <code>对称加密</code> 的方式加密明文数据</li></ul><p>采用 [混合加密] 原因：</p><ul><li><code>对称加密</code> 只有一个密钥，运算速度快，密钥需保密，无法做到安全的交换</li><li><code>非对称加密</code> 使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了交换问题但速度慢。</li></ul><ol start="2"><li><code>摘要算法 + 数字签名</code></li></ol><p>为保证传输内容不被篡改，需对内容计算出一个 [指纹] ，然后同内容一起传输给对方；收到后先对内容计算一个 [指纹] ，然后跟发送方传输的 [指纹] 进行比较，如果不相同，则认为内容被篡改。</p><p>那么，<code>摘要算法(哈希函数) 来计算出内容的哈希值</code>，也就是 [指纹] ，<code>哈希值是唯一的，且无法通过哈希值推导出内容</code></p><p>通过哈希算法可以确保内容不被篡改， <code>但是不能保证 [内容 + 哈希值] 不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。</code></p><p>计算机会用 <code>非对称加密算法</code> 解决。通过 [私钥加密，公钥解密] 的方式，确认消息身份，也就是 <code>数字签名算法</code>，加密的内容不是内容本身，而是 <code>对内容的哈希值加密</code> 。</p><ol start="3"><li><code>数字证书</code></li></ol><p>服务器把公钥注册到数字证书认证机构中， <code>数字证书认证机构会颁发一个数字证书</code> ，这个证书中包含了公钥，以及一些其他信息，比如服务器的域名，过期时间等。<br>客户端拿到服务器的数字证书使用CA的公钥确认服务器的数字证书真实性，从数字证书获取服务器公钥对报文加密后发送，服务器再用私钥进行解密。这样就安全了。</p><h3 id="HTTP-1-1-相比-HTTP-1-0"><a href="#HTTP-1-1-相比-HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0</h3><p>改进</p><ul><li>使用 <code>长连接</code></li><li>支持 管道 网络传输，只要第一个请求发送了，不必等其回来，就可以发送第二个</li></ul><p>瓶颈</p><ul><li>请求&#x2F;响应头未经压缩就发送，首部信息越多延迟越大</li><li>发送冗长的首部。每次发送相同的首部造成的浪费较多</li><li>服务器按请求的顺序响应，造成 <code>响应对头阻塞</code></li><li>没有请求优先级控制</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h3 id="HTTP-2-的优化"><a href="#HTTP-2-的优化" class="headerlink" title="HTTP&#x2F;2 的优化"></a>HTTP&#x2F;2 的优化</h3><ul><li><p>头部压缩<br>如果同时发出多个请求，他们的头是一样的或相似的，协议会帮助 <code>消除重复部分</code><br>基于 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头部信息表，所有字段都会存入这个表，生成一个索引号，以后不会发送同样字段，只发送索引号，减少头部信息</p></li><li><p>二进制格式<br>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里纯文本的报文形式，全面采用 <code>二进制格式</code> ，头部信息和数据体都是二进制，并且统称为帧： <code>头信息帧</code>、 <code>数据帧</code>。<br>这样对计算机非常友好，计算机不用解析，增加数据传输效率</p></li><li><p>并发传输<br>引入 Stream 概念，多个 Stream复用在一条 TCP 连接上<br><code>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID有序组装 HTTP 消息，不同 Stream 的帧可以乱序发送，因此可以并发不同的 Stream， HTTP/2 可以并行交错地发送请求和响应</code></p></li><li><p>服务器推送<br>HTTP&#x2F;2 中服务器不再被动地响应，可以 <code>主动</code> 向客户端发送消息。<br>客户端和服务器 <code>双方都可以建立 Stream</code> ， <code>客户端建立的是 奇数号</code> ， <code>服务器建立的是偶数号</code>。</p></li></ul><p>HTTP&#x2F;2的缺陷<br>解决了 HTTP&#x2F;1 队头阻塞， <code>但响应对头阻塞问题仍然存在。</code></p><p><code>HTTP/2 是基于 TCP协议来传输数的， TCP 是字节流协议， TCP层必须保证收到的字节流是完整的且连续的，这样内核才会将缓冲区的数据返回给 HTTP 应用，那么当 [前1个字节数据] 没到达时， 后面收到的只能存放在内核缓冲区，等这1个字节数据到达时，内核才会返回给应用层，应用层才能处理。 这就是 HTTP/2 队头阻塞</code></p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><p>TCP 是 <code>面向连接的、可靠的、基于字节流</code> 的传输层通信协议。</p><p>TCP 头的格式<br><img src="/img/learn/tcp-header.png" alt="TCP 头"></p><p>TCP 连接是需要客户端与服务端达成三个信息共识</p><ul><li>Socket：由 IP 地址和端口号组成</li><li>序列号：用来解决乱序问题</li><li>窗口大小：用来做流量控制</li></ul><p>最大 TCP 连接数 &#x3D; 客户端IP数 ✖ 客户端的端口数</p><h3 id="UDP-和-TCP-有什么区别"><a href="#UDP-和-TCP-有什么区别" class="headerlink" title="UDP 和 TCP 有什么区别"></a>UDP 和 TCP 有什么区别</h3><p>UDP 协议非常简单，头部只有 <code>8</code> 个字节</p><ul><li>源端口和目标端口号(各16位)：告诉UDP发送给哪个进程</li><li>包长度(16位)：保存了 UDP 首部长度和数据长度之和</li><li>校验和(16位)：校验和为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传送中受损的 UDP 包</li></ul><p>区别</p><ol><li>连接</li></ol><ul><li>TCP 是 <code>面向连接的</code>，传输前需要建立连接</li><li>UDP 不需要连接</li></ul><ol start="2"><li>服务对象</li></ol><ul><li>TCP 是一对一两点服务</li><li>UDP 支持一对一、一对多、多对多</li></ul><ol start="3"><li>拥塞控制、流量控制</li></ol><ul><li>TCP 又拥塞控制和流量控制机制，保证数据传输安全性</li><li>UDP 则没有，即使网络拥堵，也不会影响 UDP 发送速率</li></ul><ol start="4"><li>首部开销</li></ol><ul><li>TCP 首部长度有一定开销，首部没有使用 [选项] 字段时是 <code>20</code> 字节，如果使用会更长</li><li>UDP 首部长度是固定的 <code>8</code> 字节</li></ul><ol start="5"><li>分片</li></ol><ul><li>TCP的数据大小超过 <code>MSS</code>，则会在传输层分片</li><li>UDP 的数据大小超过 <code>MTU</code>，则会在网络层分片</li></ul><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p>TCP 是面向连接的协议，所以使用 TCP 前必须建立连接，而 <code>建立连接时通过三次握手进行的</code></p><ol><li>客户端向服务器发送一个 <code>SYN报文</code> ，该报文初始化首部的[序列号]，同时把 <code>SYN</code> 标志位设置为1，表示发起连接。</li><li>服务器收到该报文后，如果允许连接，首先初始化自己的 [序列号] ，其次把 [确认应答号] 填入 <code>客户端的序列号 + 1</code>，接着把 <code>SYN</code> 和 <code>ACK</code> 标志位都设置为1，表示接受连接。</li><li>客户端收到服务器的报文后，初始化自己的 [确认应答号] ，然后把 [序列号] 填入 <code>服务器的序列号 + 1</code>，最后把 <code>ACK</code> 标志位设置为1，最后把报文发送给服务端，之后处于 <code>ESTABLISHED</code> 状态</li><li>服务端收到报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ol><p>在三次握手过程中，<code>第三次握手可以携带数据，前两次是不可以携带数据的</code></p><h4 id="为什么是三次握手，不是两次、四次？"><a href="#为什么是三次握手，不是两次、四次？" class="headerlink" title="为什么是三次握手，不是两次、四次？"></a>为什么是三次握手，不是两次、四次？</h4><ul><li>三次握手可以 <code>阻止重复历史连接的初始化</code> (主要原因)</li><li>同步双方初始化序列号</li><li>避免资源浪费</li></ul><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位为 <code>1</code> 的报文，即 <code>FIN报文</code> ，之后客户端进入 <code>FIN_WAIT_1</code> 状态</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接收服务端进入 <code>CLOSE_WAIT</code> 状态</li><li>等服务端处理完后就向 客户端发送 <code>FIN</code> 报文，即 <code>FIN</code> 报文，服务端进入 <code>LAST_ACK</code> 状态</li><li>客户端收到服务端 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，进入 <code>TIME_WAIT</code> 状态，<code>服务端收到 ACK 应答后，就进入 CLOSE 状态，客户端等待 2MSL (报文最大生存时间) ，进入 CLOSED 状态</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/posts/learn/mysql/"/>
      <url>/posts/learn/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>摘要，记录一些自己认为重要需要学习的。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。<br>INT(11) 中的<code>数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的</code>。  </p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><code>FLOAT</code> 和 <code>DOUBLE</code> 浮点类型，<code>DECIMAL</code> 为高精度小数类型。  </p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>主要有 <code>CHAR</code> 和 <code>VARCHAR</code> 两种类型，一种是定长的，一种是变长的。<br><code>VARCHAR</code> 会保留字符串末尾的空格， <code>char</code> 会删除  </p><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p><code>DATETIME</code> 和 <code>TIMESTAMP</code><br><code>DATETIME</code> 能够保存1001年到9999年时间，精度为秒，使用8字节存储。 <code>与时区无关</code><br><code>TIMESTAMP</code> 和UNIX时间戳相同，保存从1970年1月1日午夜以来的秒数，使用4个字节，只能表示从1970-2038年。 <code>与时区有关</code> 。  </p><h3 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h3><ul><li><code>更小</code> 的数据类型通常更快，<code>因为它占用更少磁盘、内存和CPU缓存，并且处理周期少</code>  </li><li><code>简单就好</code> 例如：整形比字符串操作代价更小  </li><li><code>避免使用NULL</code> 如果查询列包含NULL，对SQL来说优化更难，因为 <code>NULL使得索引、统计和值比较变得复杂， 尽量使索引包含的字段设置成 NOT NULL</code></li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>MySQL默认的 <code>事务型引擎</code> ，支持真正的 <code>在线热备份</code> 。  </p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。 <code>但在表有读取操作的同时，也可以往表中插入新的记录</code> ，这被称为并发插入(CONCURRENT INSERT)。  </p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li>事务：Innodb是事务型，可以使用 <code>Commit</code> 和 <code>Rollback</code></li><li>并发：MyISAM 只支持 表级锁 ， InnoDB支持 <code>行级锁(即锁一条数据)</code> 。</li><li>外键：InnoDB支持</li><li>备份： InnoDB支持在线热备份</li></ul><h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><p><code>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。</code> InnoDB存储引擎中默认每个页的大小为 <code>16KB</code> ，可通过参数 <code>innodb_page_size</code> 将页的大小设置为4K、8K、16K</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。<br>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。  </p><p><code>B Tree 和 B + Tree的最大区别</code>  </p><ul><li>B Tree每个节点都带有key和data，而 B + Tree <code>非叶子节点只有key</code>，所以<code>相同量的数据B + Tree更加矮胖，减少了检索次数，更加高效</code>。</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。 <code>插入删除操作记录会破坏平衡树的平衡性</code> ，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。<code>尽量减少插入或使键有序，也减少删除</code>  </p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li><code>对索引使用函数</code>  </li><li><code>OR 条件左边是索引右边不是索引</code>  </li><li><code>左模糊查询或者左右模糊查询</code>  </li><li><code>未满足最左前匹配</code>  </li><li><code>查询条件左边为字符串出现了隐式转换</code></li></ul><h3 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h3><ul><li>通过 <code>explain</code> 进行语法分析，分析key是否用了索引，rows扫描的行数等</li><li><code>尽量不要select *，返回必要的列</code>， <code>尽量用LIMIT限制返回的行</code>  </li><li><code>缓存重复查询的数据，可以避免重复查询数据库，还能提高查询效率</code></li><li><code>减少扫描行数，尽量使用覆盖索引</code>  </li><li>对大SQL进行分解,<code>因为一个大DML SQL会锁住很多数据，耗尽资源，阻塞很多小而重要的SQL</code>， 分解SQL<code>易于让缓存利用更加高效，在应用层进行连接，可以更容易对数据库进行拆分，从而更好做到高性能和可伸缩</code></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>读未提交(一个事务能<code>读到另外一个事务未提交的数据</code>)</li><li>读已提交(一个事务提交的数据能被其他事务读取)</li><li>可重复读(一个事务读取的数据和事务 <code>开启时保持一致</code> )  <code>InnoDB默认隔离级别</code>   </li><li>串行化(对记录进行 <code>加锁</code> ，如果多个事务发生 <code>读写冲突</code> ， <code>后访问的事务必须等前一个事务执行完成</code> 才能继续执行)</li></ul><h3 id="隔离级别的实现方式"><a href="#隔离级别的实现方式" class="headerlink" title="隔离级别的实现方式"></a>隔离级别的实现方式</h3><ul><li>对于[读未提交] 直接读取最新数据即可  </li><li>对于[串行化] ，通过加读写锁来避免并行访问</li><li>对于 [读已提交] 和 [可重复读] ，通过<code>Read View</code> 实现， <code>区别在于创建Read View的时机不同，Read View类似于数据快照，[读已提交]在[每个语句执行前]生成，而[可重复读]则是在[启动事务时]生成一个 Read View</code></li></ul><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h3><p>InnoDB引擎在[可重复读]隔离级别下，<code>很大程度上避免了幻读</code> </p><ul><li>针对 <code>快照读</code>(普通select语句)，<code>通过 MVCC 方式解决幻读</code><br>· 快照读是 <code>不加锁读，基于MVCC实现的，当隔离级别是可串行化时，会自动退化成当前读</code></li><li>针对<code>当前读</code>(select.. for update) <code>通过next-key lock(记录锁+间隙锁)方式解决幻读</code><br>· 当前读是指读取最新数据，读取保证其他并发事务不能修改当前记录， <code>会对读取数据进行加锁</code></li></ul><h3 id="Read-View在MVCC中的工作"><a href="#Read-View在MVCC中的工作" class="headerlink" title="Read View在MVCC中的工作"></a>Read View在MVCC中的工作</h3><p>Read View中的四个字段可以把事务分为 <code>已经提交的事务</code>、 <code>当前事务id</code> 、<code>创建Read View时，当前活跃且未提交事务的id范围</code>以及 <code>还未开始的事务</code><br>聚簇索引中包含两个隐藏字段 <code>对该行更改的事务trx_id</code> 和 <code>指向旧版本的指针，旧版本的记录写入到 undo 日志中</code>  </p><p>一个事务对记录进行访问时，会将 <code>trx_id在Read View中进行比较</code>  </p><ul><li>如果 <code>trx_id小于最小活跃事务id</code> ,则表示该版本是在创建此Read View之前已经提交了的版本，因此可见  </li><li>如果 <code>trx_id大于等于还未开始事务的id</code> ,则表示该记录版本是  <code>在创建该Read View后启动事务更改的，所以该版本不可见</code>  </li><li>如果 <code>trx_id在上述情况之间，则需判断是否在活跃且未提交事务id范围中</code><br>· 如果trx_id<code>在已启动且未提交事务范围中，则表明生成该版本的事务还在活跃，所以该版本不可见</code><br>· 如果trx_id<code>不在已启动且未提交事务范围中，则表明生成该版本的事务已经提交，所以该版本可见</code>  </li><li>虽然MVCC只是很大程度避免了幻读， <code>但还是存在幻读</code> ，比如 <code>事务A更新了一条事务B插入的记录，那么事务A前后两次查询的记录就不一样了</code></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>MySQL加锁可以分为 <code>全局锁</code> 、 <code>表锁</code> 、 <code>行锁</code> 三类</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul><li>元数据锁<br>· 对一张表进行CRUD时，会自动加 <code>MDL 读锁</code><br>· 对一张表进行结构变化时，会自动加 <code>MDL 写锁</code></li></ul><p>MDL锁是为了保证当前用户进行操作时，防止其他线程对这个表结构进行更改。<code>写锁优先级高于读锁</code></p><ul><li><p>意向锁</p></li><li><p>AUTO-INC锁<br>表主键为自增时，<code>在新增数据时，会持有该锁，在新增完成后就会释放。</code></p></li></ul><p>Innodb提供了一种轻量锁，<code>给自增字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</code></p><h3 id="行级锁种类"><a href="#行级锁种类" class="headerlink" title="行级锁种类"></a>行级锁种类</h3><ul><li><p>记录锁(锁住一条记录)<br>· 当事务当前读查询获取到该记录的记录锁， <code>其他事务对该记录的更新和删除会发生阻塞</code>，如果其他事务进行插入不会阻塞，因为会报错主键重复</p></li><li><p>间隙锁(锁住一个范围，<code>左开有开区间</code>)<br>·  <code>只存在于可重复读级别，目的是为了解决可重复读的幻读</code><br>· <code>两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥，因为间隙锁目的是为了防止插入幻影记录</code> </p></li><li><p>next-key lock锁(记录锁和间隙锁的组合， <code>左开右闭区间</code>)</p></li></ul><h3 id="针对当前读加锁"><a href="#针对当前读加锁" class="headerlink" title="针对当前读加锁"></a>针对当前读加锁</h3><h3 id="MySQL如何加锁"><a href="#MySQL如何加锁" class="headerlink" title="MySQL如何加锁"></a>MySQL如何加锁</h3><p>加锁的对象是 <code>索引</code>，加锁的基本单位是<code>next-key lock，左开右闭区间</code>  </p><p>在某些情况下，如果使用记录锁或间隙锁就足以防止幻读现象的发生，那么next-key lock就会退化成记录锁或间隙锁。  </p><ul><li><p>当我们用 <code>主键索引进行等值查询</code> ，<code>如果记录存在，则退化成 [记录锁] ， 如果记录不存在，则退化成 [间隙锁] </code>  </p></li><li><p>当我们用<code>主键索引进行范围查询时</code>，会对每一个扫描到的索引加next-lock锁<br>· 针对<code>大于等于</code>，因为存在等值，所以对扫描到的记录<code>退化成记录锁</code><br>· 针对<code>小于等于或者小于</code>，  <code>取决于条件值的记录是否存在</code><br>· 如果<code>记录在表中不存在</code> ， <code>扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化成间隙锁</code>，其他扫描到的记录加next-key锁<br>· 当查询 <code>记录在表中存在</code> ，如果是 <code>小于条件</code> ， <code>扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化成间隙锁</code> ，其他为next-lock锁   </p></li><li><p>当我们用<code>非主键索引进行等值查询时</code> ， <code>因为存在两个索引，一个是主键索引，一个是二级索引，所以在加锁时，同时会对这两个索引加锁，但对主键索引加锁时，只有满足查询条件的记录才会对它们的主键索引加锁</code><br>· 当 <code>查询的记录存在</code> 时，<code>会进行二级索引扫描，直到扫描到第一个不符合条件的记录就停止，然后对扫描到的二级索引添加 next-lock锁 ，而对于第一个不符合条件的索引退化成间隙锁，同时在符合条件的记录的主键索引添加记录锁</code><br>· 当 <code>查询记录不存在</code> 时，扫描到第一个不符合条件的二级索引记录，该二级索引的next-key锁会退化成间隙锁。因为不满足查询条件，所以<code>不会对主键索引加锁</code>  </p></li><li><p>当我们用<code>非主键索引进行范围查询时，索引的next-lock 锁不会退化！！！</code></p></li></ul><h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><ol><li><p>连接器<br>· 首先经过连接器进行连接，先经过 <code>TCP</code> 三次握手建立连接后， <code>验证账号密码</code> ,通过则建立长连接</p></li><li><p>查询缓存(8.0将这一部分删掉)<br>· 如果有这一步则进行查询看是否执行过这一条语句，缓存以key-value形式存储，key为查询语句  </p></li><li><p>解析器-解析SQL<br>· 进行 <code>词法分析</code>获取关键字 ， <code>语法分析</code>  判断SQL满足规则，建立SQL语法树。</p></li><li><p>执行SQL<br>· <code>预处理器</code> 检查字段是否存在，将*扩展为所有列<br>· <code>优化器</code> 负责将语句的执行方案确定下来，基于内部的选择来决定走哪个索引等<br>· <code>执行器</code> 与存储引擎进行交互</p></li></ol><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="undo-log-回滚日志-实现事务中的原子性，用于事务-回滚-和-MVCC"><a href="#undo-log-回滚日志-实现事务中的原子性，用于事务-回滚-和-MVCC" class="headerlink" title="undo log(回滚日志) 实现事务中的原子性，用于事务 回滚 和 MVCC"></a>undo log(回滚日志) 实现事务中的原子性，用于事务 回滚 和 MVCC</h3><ul><li>在 <code>插入</code> 一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录 <code>删掉</code> 就好了；</li><li>在 <code>删除</code> 一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录 <code>插入</code> 到表中就好了；</li><li>在 <code>更新</code> 一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列 <code>更新为旧值</code> 就好了。</li></ul><h3 id="redo-log-重做日志-实现事务中的持久化，用于掉电等故障恢复"><a href="#redo-log-重做日志-实现事务中的持久化，用于掉电等故障恢复" class="headerlink" title="redo log(重做日志) 实现事务中的持久化，用于掉电等故障恢复"></a>redo log(重做日志) 实现事务中的持久化，用于掉电等故障恢复</h3><p>Buffer Pool会把存储的数据划分为若干个页，默认 <code>16KB</code> ，叫做 <code>缓存页</code></p><p>Buffer Pool 是为了提高读写效率，但它是基于内存，内存不可靠。</p><p>为了防止断电等导致数据丢失，当记录一条数据时， Innodb 会先更新内存(同时标记为 <code>脏页</code> )，会在合适的时机，由后台线程将缓存在 Buffer Pool 中的数据刷到磁盘上，这就是 <code>WAL 技术</code></p><p>redo log 和 undo log的区别</p><ul><li>redo log 记录了此次事务 <code>完成后</code> 的数据状态，记录的是更新 <code>之后</code> 的新值</li><li>undo log 记录此次事务 <code>开始时</code> 的数据状态，记录的是 <code>之前 </code>的旧值<br>事务提交之前发生崩溃，通过undo log 进行回滚数据，事务提交后发生崩溃，通过 redo log 进行恢复<br>redo log 是追加方式，所以是[顺序写]入磁盘；而写入数据是[随机写]。这就好比一个记事本按顺序一直往下写和写一个字要找对应的页。<br>redo log 实现了 <code>事务的持久性，让 MySQL 有了崩溃恢复的能力</code>， <code>将写操作从[随机写]转变为[顺序写]，提升写入磁盘性能</code>。</li></ul><p>产生的 redo log 也 <code>不是直接写入磁盘</code> ，因为这样产生大量 I&#x2F;O 效率低下</p><p>redo log 有自己的缓存- <code>redo log buffer</code><br>写入时机：</p><ul><li>MySQL 正常关机</li><li>当 redo log buffer 写入量超过 <code>1/2</code> 时，将 redo log buffer 写入磁盘</li><li>Innodb 后台线程每隔一秒，持久化一次</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</li></ul><p>redo log 实际是由两个 log 文件(一个大小默认为 1GB )组成，两个文件循环写， <code>当redo log写的 Buffer Pool 脏数据超过redo log大小，即 redo log 写满后</code> ，就会阻塞 MySQL ，此时 <code>会停下来将 Buffer Pool 中的脏数据刷新到磁盘中，然后标记 redo log 哪些可以删除，接着对旧的 redo log 进行擦除，腾出空间，然后 MySQL 恢复正常</code></p><h3 id="bin-log-归档日志-主要用于数据备份和主从复制"><a href="#bin-log-归档日志-主要用于数据备份和主从复制" class="headerlink" title="bin log(归档日志) 主要用于数据备份和主从复制"></a>bin log(归档日志) 主要用于数据备份和主从复制</h3><p>MySQL 执行完一条更新操作后，还会生成一条 binlog，等事务提交后，会将该事务产生的 binlog统一写入 binlog 文件。</p><p>binlog 主要记录所有数据库表结构变更和表数据修改的日志， <code>不会记录查询类的操作</code></p><h4 id="redo-log-和-binlog区别"><a href="#redo-log-和-binlog区别" class="headerlink" title="redo log 和 binlog区别"></a>redo log 和 binlog区别</h4><ol><li>适用范围不同<ul><li>binlog是 MySQL 的 Server 层实现的，任何存储引擎都可以使用</li><li>redo log 是 Innodb 存储引擎实现的日志</li></ul></li><li>文件格式不一样<ul><li>binlog 有三种格式类型：STATEMENT、 ROW、MIXED<ul><li>STATEMENT：<code>记录的是SQL语句</code> ，相当于逻辑日志；但有 <code>动态函数问题</code> ，比如用了 uuid 或 now 函数，在主库上执行的结果并不是在从库上执行的结果，这种随时在变的函数会导致数据复制不一致。</li><li>ROW：<code>记录的是数据变更</code> ，每行数据变化的结果都会记录，使 binlog 文件过大</li><li>MIXED: <code>STATEMENT + ROW</code> 模式，会根据不同情况使用</li></ul></li><li>redo log是物理日志，记录某个数据页的修改，比如对XX表空间中的YY数据页ZZ偏移量的地方AAA更新</li></ul></li><li>写入方式<ul><li>binlog 是追加写，写满之后新建</li><li>redo log 是循环写，日志空间固定</li></ul></li><li>用途不一样<ul><li>binlog 是数据备份、主从复制</li><li>redo log 掉电等故障恢复</li></ul></li></ol><h4 id="主从复制模型"><a href="#主从复制模型" class="headerlink" title="主从复制模型"></a>主从复制模型</h4><ul><li>同步复制: MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回结果。</li><li>异步复制(默认): MySQL 主库提交事务的线程不等待从库复制成功，直接返回。</li><li>半同步复制：MySQL 5.7 版本之后新增的方式，事务不用等待所有从库复制成功响应， <code>只用返回一部分复制成功响应即可</code>。半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。</li></ul><p>当一个事务提交后，其 <code>产生的 binlog 先写入 binlog cache </code> ，每个线程都有一个。</p><p>binlog 刷盘是根据参数 <code>sync_binlog</code> 来控制的</p><ul><li><code>sync_binlog=0</code>: 每次提交事务只 write，不fsync，后续由系统决定</li><li><code>sync_binlog=1</code>: 每次提交事务都 write 和 fsync</li><li><code>sync_binlog=N</code>: N 次 write 后，执行 fsync</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12306(一)</title>
      <link href="/posts/12306/12306(%E4%B8%80)/"/>
      <url>/posts/12306/12306(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>本项目为<a href="https://github.com/Wangbangc/12306">开源项目</a></p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>先了解相关包，对项目有个整体的了解。<br><img src="/img/12306/package.png" alt="包相关说明" /></p><p>配置相关看 <a href="https://nageoffer.com/12306/environment-configuration/">官方环境搭建</a> 就行了</p><h1 id="站点查询相关"><a href="#站点查询相关" class="headerlink" title="站点查询相关"></a>站点查询相关</h1><p>因为 <code>查询大多都类似</code> ，比较复杂的就是首页进行车票查询，所以再这里只写一个</p><p>接口 <code>/api/ticket-service/ticket/query</code> ，查询车票(默认访问查询 <code>北京到杭州的车票</code> )访问首页即可触发</p><p>大致流程: 请求首先会在网关中被拦截，然后通过黑白名单进行过滤，请求再到相应服务端进行处理，对于上述车票的查询，<code>网关路由到服务端后首先查询缓存，查询不到就查询数据库，并将相关数据存储在缓存中</code>。</p><p>具体流程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端接口</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api/ticket-service/ticket/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;TicketPageQueryRespDTO&gt; pageListTicketQuery</span><br><span class="line"><span class="comment">// 参数为 两站台缩写</span></span><br><span class="line">(TicketPageQueryReqDTO requestParam) &#123;</span><br><span class="line">    <span class="keyword">return</span> Results.success(</span><br><span class="line">        ticketService.pageListTicketQueryV1(requestParam));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到实现层后，第一行代码就是利用 <code>责任链模式</code>，首先 <code>对参数进行校验</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 责任链模式 验证城市名称是否存在、不存在加载缓存以及出发日期不能小于当前日期等等</span></span><br><span class="line">ticketPageQueryAbstractChainContext.handler</span><br><span class="line"><span class="comment">// 第一个参数是标记，用于区分不同的责任链</span></span><br><span class="line"><span class="comment">// 第二个是要进行校验的参数</span></span><br><span class="line">(TicketChainMarkEnum.TRAIN_QUERY_FILTER.name(), requestParam);</span><br></pre></td></tr></table></figure><p>再进入到 <code>ticketPageQueryAbstractChainContext</code> 时，首先我们要看一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个单接口， <code>文中用了大量的 @FunctionalInterface 来标识接口，我能想到的目的就是规范开发， 只定义一个接口增加灵活性，方便扩展 ?(泛型接口，不用具体实现，函数式编程直接传入具体实现) </code></p><p>接下来再进入 <code>ticketPageQueryAbstractChainContext</code> 查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AbstractChainContext</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;AbstractChainHandler&gt;&gt; abstractChainHandlerContainer </span><br><span class="line">    = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 责任链组件执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mark         责任链组件标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestParam 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(String mark, T requestParam)</span> &#123;</span><br><span class="line">        List&lt;AbstractChainHandler&gt; abstractChainHandlers </span><br><span class="line">        = abstractChainHandlerContainer.get(mark);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(abstractChainHandlers)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String</span><br><span class="line">            .format(<span class="string">&quot;[%s] Chain of Responsibility ID is undefined.&quot;</span>, mark));</span><br><span class="line">        &#125;</span><br><span class="line">        abstractChainHandlers.</span><br><span class="line">        forEach(each -&gt; each.handler(requestParam));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在初始化时就进行装载， 我给忘了在哪里加载来着。chao TODO</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;String, AbstractChainHandler&gt; chainFilterMap = ApplicationContextHolder</span><br><span class="line">                .getBeansOfType(AbstractChainHandler.class);</span><br><span class="line">        chainFilterMap.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">            List&lt;AbstractChainHandler&gt; abstractChainHandlers = </span><br><span class="line">            abstractChainHandlerContainer.get(bean.mark());</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(abstractChainHandlers)) &#123;</span><br><span class="line">                abstractChainHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            abstractChainHandlers.add(bean);</span><br><span class="line">            List&lt;AbstractChainHandler&gt; actualAbstractChainHandlers = </span><br><span class="line">            abstractChainHandlers.stream()</span><br><span class="line">                    .sorted(Comparator.comparing(Ordered::getOrder))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">            abstractChainHandlerContainer.put(bean.mark(), actualAbstractChainHandlers);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DO: <code>上述初始化是因为实现了 CommandLineRunner 接口，这个接口只有一个方法就是 run() ，专门用于程序启动时进行初始化</code> ，大概逻辑如下</p><ol><li>引入本模块</li><li>定义接口，继承 <code>接口</code> <code>AbstractChainHandler</code> ，重写进行标注 <code>mark</code>，用于不同过滤器链</li><li>实现所定义的接口，实现方法 <code>handler()</code> ，处理逻辑</li><li><code>当该模块启动时，会自动调用 run() 方法加载到 abstractChainHandlerContainer 容器中，这样就完成了 责任链模式根据mark()标记进行不同流程验证</code></li></ol><p>上述最重要的是 <code>abstractChainHandlers.forEach(each -&gt; each.handler(requestParam));</code><br>将参数依次传到责任链进行相关校验</p><p><code>之后基本上都是查询数据库写入缓存的操作，我只写逻辑，没怎么给注释</code> </p><p><code>感觉代码很美</code>，可以多看看写法，很帅</p><p>校验完成后尝试从 Redis 缓存中进行获取两地信息，如果获取不到就加锁用 <code>双重校验锁(锁前查询一次，锁后再查询一次)</code> 进行 数据库获取 <code>所有站台缩写与城市之间的映射关系</code> 查询并插入 缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; stationDetails = stringRedisTemplate.opsForHash()</span><br><span class="line">        .multiGet(REGION_TRAIN_STATION_MAPPING,</span><br><span class="line">                Lists.newArrayList(requestParam.getFromStation(), requestParam.getToStation()));</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stationDetails.stream().filter(Objects::isNull).count();</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(LOCK_REGION_TRAIN_STATION_MAPPING);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stationDetails = stringRedisTemplate.opsForHash()</span><br><span class="line">                .multiGet(REGION_TRAIN_STATION_MAPPING, Lists.newArrayList(requestParam.getFromStation(), requestParam.getToStation()));</span><br><span class="line">        count = stationDetails.stream().filter(Objects::isNull).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;StationDO&gt; stationDOList = stationMapper.selectList(Wrappers.emptyWrapper());</span><br><span class="line">            Map&lt;String, String&gt; regionTrainStationMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            stationDOList.forEach(each -&gt; regionTrainStationMap.put(each.getCode(), each.getRegionName()));</span><br><span class="line">            stringRedisTemplate.opsForHash().putAll(REGION_TRAIN_STATION_MAPPING, regionTrainStationMap);</span><br><span class="line">            stationDetails = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            stationDetails.add(regionTrainStationMap.get(requestParam.getFromStation()));</span><br><span class="line">            stationDetails.add(regionTrainStationMap.get(requestParam.getToStation()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到数据后，再通过同样的方式，获取到 <code>所有北京到杭州站点的车票</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TicketListDTO&gt; seatResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">buildRegionTrainStationHashKey</span> <span class="operator">=</span> String.format(REGION_TRAIN_STATION, stationDetails.get(<span class="number">0</span>), stationDetails.get(<span class="number">1</span>));</span><br><span class="line">Map&lt;Object, Object&gt; regionTrainStationAllMap = stringRedisTemplate.opsForHash().entries(buildRegionTrainStationHashKey);</span><br><span class="line"><span class="keyword">if</span> (MapUtil.isEmpty(regionTrainStationAllMap)) &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(LOCK_REGION_TRAIN_STATION);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        regionTrainStationAllMap = stringRedisTemplate.opsForHash().entries(buildRegionTrainStationHashKey);</span><br><span class="line">        <span class="keyword">if</span> (MapUtil.isEmpty(regionTrainStationAllMap)) &#123;</span><br><span class="line">            LambdaQueryWrapper&lt;TrainStationRelationDO&gt; queryWrapper = Wrappers.lambdaQuery(TrainStationRelationDO.class)</span><br><span class="line">                    .eq(TrainStationRelationDO::getStartRegion, stationDetails.get(<span class="number">0</span>))</span><br><span class="line">                    .eq(TrainStationRelationDO::getEndRegion, stationDetails.get(<span class="number">1</span>));</span><br><span class="line">            List&lt;TrainStationRelationDO&gt; trainStationRelationList = trainStationRelationMapper.selectList(queryWrapper);</span><br><span class="line">            <span class="keyword">for</span> (TrainStationRelationDO each : trainStationRelationList) &#123;</span><br><span class="line">                <span class="type">TrainDO</span> <span class="variable">trainDO</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">                        TRAIN_INFO + each.getTrainId(),</span><br><span class="line">                        TrainDO.class,</span><br><span class="line">                        () -&gt; trainMapper.selectById(each.getTrainId()),</span><br><span class="line">                        ADVANCE_TICKET_DAY,</span><br><span class="line">                        TimeUnit.DAYS);</span><br><span class="line">                <span class="type">TicketListDTO</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketListDTO</span>();</span><br><span class="line">                result.setTrainId(String.valueOf(trainDO.getId()));</span><br><span class="line">                result.setTrainNumber(trainDO.getTrainNumber());</span><br><span class="line">                result.setDepartureTime(convertDateToLocalTime(each.getDepartureTime(), <span class="string">&quot;HH:mm&quot;</span>));</span><br><span class="line">                result.setArrivalTime(convertDateToLocalTime(each.getArrivalTime(), <span class="string">&quot;HH:mm&quot;</span>));</span><br><span class="line">                result.setDuration(DateUtil.calculateHourDifference(each.getDepartureTime(), each.getArrivalTime()));</span><br><span class="line">                result.setDeparture(each.getDeparture());</span><br><span class="line">                result.setArrival(each.getArrival());</span><br><span class="line">                result.setDepartureFlag(each.getDepartureFlag());</span><br><span class="line">                result.setArrivalFlag(each.getArrivalFlag());</span><br><span class="line">                result.setTrainType(trainDO.getTrainType());</span><br><span class="line">                result.setTrainBrand(trainDO.getTrainBrand());</span><br><span class="line">                <span class="keyword">if</span> (StrUtil.isNotBlank(trainDO.getTrainTag())) &#123;</span><br><span class="line">                    result.setTrainTags(StrUtil.split(trainDO.getTrainTag(), <span class="string">&quot;,&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="variable">betweenDay</span> <span class="operator">=</span> cn.hutool.core.date.DateUtil.betweenDay(each.getDepartureTime(), each.getArrivalTime(), <span class="literal">false</span>);</span><br><span class="line">                result.setDaysArrived((<span class="type">int</span>) betweenDay);</span><br><span class="line">                result.setSaleStatus(<span class="keyword">new</span> <span class="title class_">Date</span>().after(trainDO.getSaleTime()) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">                result.setSaleTime(convertDateToLocalTime(trainDO.getSaleTime(), <span class="string">&quot;MM-dd HH:mm&quot;</span>));</span><br><span class="line">                seatResults.add(result);</span><br><span class="line">                regionTrainStationAllMap.put(CacheUtil.buildKey(String.valueOf(each.getTrainId()), each.getDeparture(), each.getArrival()), JSON.toJSONString(result));</span><br><span class="line">            &#125;</span><br><span class="line">            stringRedisTemplate.opsForHash().putAll(buildRegionTrainStationHashKey, regionTrainStationAllMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再获取到 <code>车票余额、车座次相对应的价格</code> 并进行缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">seatResults = CollUtil.isEmpty(seatResults)</span><br><span class="line">                ? regionTrainStationAllMap.values().stream().map(each -&gt; JSON.parseObject(each.toString(), TicketListDTO.class)).toList()</span><br><span class="line">                : seatResults;</span><br><span class="line">        seatResults = seatResults.stream().sorted(<span class="keyword">new</span> <span class="title class_">TimeStringComparator</span>()).toList();</span><br><span class="line">        <span class="keyword">for</span> (TicketListDTO each : seatResults) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">trainStationPriceStr</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">                    String.format(TRAIN_STATION_PRICE, each.getTrainId(), each.getDeparture(), each.getArrival()),</span><br><span class="line">                    String.class,</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        LambdaQueryWrapper&lt;TrainStationPriceDO&gt; trainStationPriceQueryWrapper = Wrappers.lambdaQuery(TrainStationPriceDO.class)</span><br><span class="line">                                .eq(TrainStationPriceDO::getDeparture, each.getDeparture())</span><br><span class="line">                                .eq(TrainStationPriceDO::getArrival, each.getArrival())</span><br><span class="line">                                .eq(TrainStationPriceDO::getTrainId, each.getTrainId());</span><br><span class="line">                        <span class="keyword">return</span> JSON.toJSONString(trainStationPriceMapper.selectList(trainStationPriceQueryWrapper));</span><br><span class="line">                    &#125;,</span><br><span class="line">                    ADVANCE_TICKET_DAY,</span><br><span class="line">                    TimeUnit.DAYS</span><br><span class="line">            );</span><br><span class="line">            List&lt;TrainStationPriceDO&gt; trainStationPriceDOList = JSON.parseArray(trainStationPriceStr, TrainStationPriceDO.class);</span><br><span class="line">            List&lt;SeatClassDTO&gt; seatClassList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            trainStationPriceDOList.forEach(item -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">seatType</span> <span class="operator">=</span> String.valueOf(item.getSeatType());</span><br><span class="line">                <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;_&quot;</span>, each.getTrainId(), item.getDeparture(), item.getArrival());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">quantityObj</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().get(TRAIN_STATION_REMAINING_TICKET + keySuffix, seatType);</span><br><span class="line">                <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> Optional.ofNullable(quantityObj)</span><br><span class="line">                        .map(Object::toString)</span><br><span class="line">                        .map(Integer::parseInt)</span><br><span class="line">                        .orElseGet(() -&gt; &#123;</span><br><span class="line">                            Map&lt;String, String&gt; seatMarginMap = seatMarginCacheLoader.load(String.valueOf(each.getTrainId()), seatType, item.getDeparture(), item.getArrival());</span><br><span class="line">                            <span class="keyword">return</span> Optional.ofNullable(seatMarginMap.get(String.valueOf(item.getSeatType()))).map(Integer::parseInt).orElse(<span class="number">0</span>);</span><br><span class="line">                        &#125;);</span><br><span class="line">                seatClassList.add(<span class="keyword">new</span> <span class="title class_">SeatClassDTO</span>(item.getSeatType(), quantity, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(item.getPrice()).divide(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;100&quot;</span>), <span class="number">1</span>, RoundingMode.HALF_UP), <span class="literal">false</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">            each.setSeatClassList(seatClassList);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>到这里，基本上就结束了，中间三个代码段都是 对车票部分进行查询、缓存，还有一部分不好的地方，我找个时间补上。</p><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>这个项目查询车票流程基本这样，对于 <code>网关</code> 实现方式多，本项目是通过继承 <code>AbstractGatewayFilterFactory</code> ，主要重写 <code>apply</code> 方法实现。</p><p>有很多代码写得很美，<br>像一开始的责任链模式进行参数校验，责任链实现在包<code>frameworks.designpattern</code>(前几太看的时候我还记得是如何加载的，现在我已经忘了T_T)<br>然后就是用 <code>@FunctionalInterface</code>只写一个接口，文中用了很多，举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;StationQueryRespDTO&gt; <span class="title function_">listAllStation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> distributedCache.safeGet(</span><br><span class="line">            STATION_ALL,</span><br><span class="line">            List.class,</span><br><span class="line">            () -&gt; BeanUtil.convert(stationMapper.selectList(Wrappers.emptyWrapper()), StationQueryRespDTO.class),</span><br><span class="line">            ADVANCE_TICKET_DAY,</span><br><span class="line">            TimeUnit.DAYS</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>() -&gt; BeanUtil.convert(stationMapper.selectList(Wrappers.emptyWrapper()), StationQueryRespDTO.class)</code> 是实现 <code>CacheLoader</code> 的 <code>load()</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CacheLoader</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">load</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>这有什么好处呢？</code></p><p>我们写这样一个接口，<code>通过函数式编程方式，直接写上实现。不用再依次写具体实现，然后再调用，极大增强复用性，查这个写一个实现，查那个写一个实现</code></p><p>雅，太雅了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 12306 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.17</title>
      <link href="/posts/10-17/"/>
      <url>/posts/10-17/</url>
      
        <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>先给看看工位。</p><img src="/img/10-17/gw.jpg" alt="自己的工位"/><p>经理给我配的旧的苹果，俺不会用，就给我配了Windows。果然 <code>野猪吃不了细康</code></p><p>工作一个多月了,按考勤算钱，第一个月又遇到国庆、中秋，那几天真希望自己天天上班，狠狠赚。</p><p>这个公司很小， <code>真正在干事儿的就6个人!其中还包括经理、包括我在内的三个实习生</code> 。但人家是19年就建立的。还有一位4年老员工。</p><p>第一天进公司，就收到通知被重庆德勤给录取了。但是我才租上房啊，还大老远从学校跑来，又坐车回去。<br><img src="/img/10-17/dqlq.jpg" alt="整洋文"><br>这俩工资是一样多的，但我不想多花父母的钱就没回重庆。爸给我说让我回去，我骗他说被撤回了。(小声bb一下，我也受到一些网络影响，说德勤分配完全看运气，有些好有些差。有大佬，有导师但完全看 <code>运气</code> )</p><p>也想过回重庆现在是不是已经有更好发展，是个高楼白领了，哈哈哈。</p><p>无所谓，在哪都是学。</p><p>我这儿的经理人挺好，说话都很和气，对实习生也不错，是个 <code>技术佬</code> 。我对这样的人啊，真是像个小孩一样。这几天犯了一个错，在人面前像个沙贝一样扭扭捏捏的，真想回去抽自己一个大嘴巴子。</p><p>前几天安排写一个脚本，从数据库上把数据扒出来，因为阿里那个数据库好像是只能上传，不能保存。<br>那是我第一个活儿，写得老快了， <code>感觉自己改的代码优雅丝滑</code>（现在想想就是傻呗迷之自信） ，越看越觉得自己屌，后面发现一些错误，又修修补补，又加上日志查看进度、配置文件。又这又那，感觉代码优雅得一批。<br>结果前天同事提醒我这个脚本有个BUG，某些情况会少数据。</p><p>哈哈哈， <code>结果我就急了</code> 。也没敢问经理，也没敢告诉他，因为我觉得这太easy了， <code>索性就把查到的2/3数据全删了</code> ，重头开始。(狂删自己巴掌，下次删片，别删数据)</p><p>哈哈哈，后端开发成全栈开发，让我页面美化，这真比不过同事，就让我很焦虑。</p><p>今天早上5点才睡着，8点多又拖着疲惫身躯上班了。</p><p>今天索性一问，说没事儿，让我接着查。<br>我都删了，拿啥查，又没给他说已经把数据删了。<br>结果他来问还差多少，我就实话实说了(为啥不早给他说)</p><p>生活，就是生下来，然后活着。</p><p>我现在就想挣钱，挣大把的钱。</p><p>听一首 DAY 1 好好睡一觉吧。接下来就好好工作，好好生活。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本站</title>
      <link href="/posts/%E6%9C%AC%E7%AB%99/"/>
      <url>/posts/%E6%9C%AC%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="关于本站"><a href="#关于本站" class="headerlink" title="关于本站"></a>关于本站</h1><p>其实很早之前一直想创建一个属于自己的博客。</p><p>从自己学习Java后端开始，就尝试过自己自研一个，后面发现自己写一个博客的工作量非常大，自己的前端学得也只是逻辑方面，对于美化方面做得很烂。</p><p>很早就了解到了有现成博客模板，折腾一下发现大量配置又给搁置了。</p><p>这一次终于下定决心了，一定要弄一个出来。</p><p>2024年10月13日</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
