<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis</title>
      <link href="/posts/learn/redis/"/>
      <url>/posts/learn/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis 相关点</p><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><ol><li>String(字符串)</li><li>List(列表)</li><li>Hash(键-值)</li><li>Set(无序集合)</li><li>ZSet(有序集合)</li></ol><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String-字符串"></a>String-字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 key-value 类型的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET name lin</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 key 获得对应的 value</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET name</span></span><br><span class="line">&quot;lin&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断某个 key 是否存在</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EXISTS name</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回 key 所储存的字符串值的长度</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">STRLEN name</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某个 key 对应的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">DEL name</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量设置 key-value 类型的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">MSET key1 value1 key2 value2</span> </span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量获取多个 key 对应的 value</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">MGET key1 key2</span> </span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用场景</span></span><br><span class="line">- setnx简单的分布式锁</span><br><span class="line">- 记录用户登录</span><br><span class="line">- 常规计数</span><br></pre></td></tr></table></figure><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List-列表"></a>List-列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">LPUSH key value [value ...]</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表尾(最右边)</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">RPUSH key value [value ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的头元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">LPOP key</span>     </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的尾元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">RPOP key</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">LRANGE key start stop</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表头弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">BLPOP key [key ...] <span class="built_in">timeout</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表尾弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">BRPOP key [key ...] <span class="built_in">timeout</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">应用场景</span></span><br><span class="line">// 可以当作简单的 `消息队列`  </span><br></pre></td></tr></table></figure><h3 id="Hash-键值对"><a href="#Hash-键值对" class="headerlink" title="Hash-键值对"></a>Hash-键值对</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储一个哈希表key的键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HSET key field value</span>   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表key对应的field键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HGET key field</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在一个哈希表key中存储多个键值对</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HMSET key field value [field value...]</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量获取哈希表key中多个field键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HMGET key field [field ...]</span>       </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除哈希表key中的field键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HDEL key field [field ...]</span>    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回哈希表key中field的数量</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HLEN key</span>       </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回哈希表key中所有的键值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HGETALL key</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为哈希表key中field键的值加上增量n</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HINCRBY key field n</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用场景</span>  </span><br><span class="line">可以缓存对象信息、用户购物车</span><br></pre></td></tr></table></figure><h3 id="Set-无序键值集合"><a href="#Set-无序键值集合" class="headerlink" title="Set-无序键值集合"></a>Set-无序键值集合</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往集合key中存入元素，元素存在则忽略，若key不存在则新建</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD key member [member ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中删除元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SREM key member [member ...]</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取集合key中所有元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SMEMBERS key</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取集合key中的元素个数</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SCARD key</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断member元素是否存在于集合key中</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER key member</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中随机选出count个元素，元素不从key中删除</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER key [count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中随机选出count个元素，元素从key中删除</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP key [count]</span></span><br><span class="line">Set运算操作：</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交集运算</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SINTER key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将交集结果存入新集合destination中</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SINTERSTORE destination key [key ...]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并集运算</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SUNION key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将并集结果存入新集合destination中</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SUNIONSTORE destination key [key ...]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">差集运算</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SDIFF key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将差集结果存入新集合destination中</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SDIFFSTORE destination key [key ...]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用场景</span>  </span><br><span class="line">- Set 类型可以保证一个用户只能点一个赞  </span><br><span class="line">- 共同关注  </span><br><span class="line">- 抽奖活动</span><br></pre></td></tr></table></figure><h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset-有序集合"></a>Zset-有序集合</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往有序集合key中加入带分值元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD key score member [[score member]...]</span>   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往有序集合key中删除元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZREM key member [member...]</span>                 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回有序集合key中元素member的分值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZSCORE key member</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回有序集合key中元素个数</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZCARD key</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为有序集合key中元素member的分值加上increment</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZINCRBY key increment member</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">倒序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZREVRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回有序集合中指定分数区间内的成员，分数由低到高排序。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX key min max [LIMIT offset count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZREVRANGEBYLEX key max min [LIMIT offset count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZUNIONSTORE destkey numberkeys key [key...]</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZINTERSTORE destkey numberkeys key [key...]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用场景</span>  </span><br><span class="line">- 排行榜  </span><br><span class="line">- 电话姓名排序</span><br></pre></td></tr></table></figure><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis持久化方式</p><ol><li>AOF日志(快照 + 追加命令)</li><li>RDB快照(二进制文件)</li></ol><h3 id="AOF日志-Appen-Only-File"><a href="#AOF日志-Appen-Only-File" class="headerlink" title="AOF日志 (Appen Only File)"></a>AOF日志 (Appen Only File)</h3><p>AOF 只会记录 <code>写操作</code> ，读操作不会被记录，因为没意义</p><h4 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h4><p>如果每次修改都写入磁盘，会造成极大的资源浪费，所以redis 创建了 <code>AOF 缓冲区</code>，并提供了三种写回策略：</p><ul><li><code>Always</code> ，每次执行完写操作，同步 AOF 日志数据回硬盘</li><li><code>Everysec</code> ，每次执行完写操作，先将命令写到 AOF 内核缓冲区，每秒将缓冲区里内容写回硬盘</li><li><code>No</code> ，将写回时机交给操作系统决定</li></ul><p>这三种策略知识在控制 <code>fsync()</code> 函数调用时机</p><h4 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h4><p>为了避免 AOF 文件越写越大，提供了 <code>AOF 重写机制</code></p><p>AOF 重写机制是在重写时，读取当前数据库中所有键值对记录到[新的 AOF 文件] ，然后将新的 AOF 文件替换旧的 AOF 文件，从而实现 AOF 文件的压缩。</p><p><code>为何用新文件替换旧文件？</code> 这样确保如果重写失败了，也不会对现有 AOF 文件造成污染。</p><p>AOF 重写过程由后台子进程 <code>bgrewriteaof</code> 来完成</p><p>主进程会复制一份 <code>[页表](记录虚拟地址与物理地址映射关系) 给子进程</code> ，这样做 <code>节约物理内存资源</code></p><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>当父进程或子进程对内存发起写操作时， CPU 会触发 <code>写保护中断</code> ，操作系统会进行 <code>物理内存复制</code>，并重新设置映射关系，将父进程的内存读写权限设置为 <code>可读写</code>，最后才对内存进行写操作，这个过程叫 <code>写时复制(Copy On Write)</code></p><p>主进程修改已经存在的 key-value ，就会发生 写时复制 ， <code>只会复制主进程修改的物理内存数据，没修改的内存还是与子进程共享</code> </p><p>为了解决 <code>写时复制主线程修改的值与 AOF 文件中数据不一致问题</code>， redis 设置了 <code>AOF 重写缓冲区</code></p><p>当重写 AOF 期间，当 redis 执行完一个写命令，会 <code>同时将这个命令写到 [AOF 缓冲区] 和 [AOF 重写缓冲区]</code></p><p>当子进程完成 AOF 重写工作后，会向主进程发送一条信号，主进程收到信号会做以下事情</p><ul><li>将 AOF 重写缓冲区的数据写入 AOF 文件</li><li>覆盖原有 AOF 文件</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>AOF 记录的写操作命令， RDB记录的是某一瞬间的数据快照</p><p>因此在进行数据恢复时， RDB 优于 AOF</p><h4 id="RDB-生成时机"><a href="#RDB-生成时机" class="headerlink" title="RDB 生成时机"></a>RDB 生成时机</h4><p>RDB 提供 <code>save</code> 和 <code>bgsave</code>，区别在于是否在[主线程执行]</p><p>RDB通过配置文件来实现每隔一段时间自动执行一次 bgsave 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br></pre></td></tr></table></figure><p>选项名叫save ，实际执行的是 bgsave</p><ul><li>900 秒内，对数据库进行了至少 1 次修改</li><li>300 秒内，对数据库至少进行了 10 次修改</li></ul><p>注： <code>RDB 快照是全量快照</code></p><h4 id="RDB-的写时复制"><a href="#RDB-的写时复制" class="headerlink" title="RDB 的写时复制"></a>RDB 的写时复制</h4><p>当在进行 bgsave 时，主进程依旧能 <code>继续处理操作命令</code></p><p>如果这时主线程要 <code>修改共享数据里的某一块数据</code> (如 A)，就会发生写时复制，这块数据的 <code>物理内存会被复制一份(A·)</code> ，然后 <code>主线程操作数据副本(A·)</code> ，此时 <code>bgsave 子进程可以继续把原来的数据(A) 写入到 RDB 文件中</code></p><p>注意，<code>发生写时复制时， RDB 快照保存的是原本的内存数据</code> ，而修改的数据是没办法写入本次 RDB 文件的， <code>主线程刚修改的数据交由下次处理</code></p><h3 id="aof-use-rdb-preamble-yes"><a href="#aof-use-rdb-preamble-yes" class="headerlink" title="aof-use-rdb-preamble yes"></a>aof-use-rdb-preamble yes</h3><p>混合使用 AOF 和 RDB ，进行 混合持久化</p><p><code>前半部分是 RDB 的全量数据，后半部本是 AOF 格式的增量数据</code></p><p>这样 <code>加载的时候速度会很快</code></p><p>并且 加载完 RDB 内容后，才会加载后半部分的 AOF 内容， 这里的内容是 redis 后台子进程重写 AOF 期间，主线程处理的操作命令，使 <code>数据丢失更少</code></p><h2 id="过期删除策略和内存淘汰策略"><a href="#过期删除策略和内存淘汰策略" class="headerlink" title="过期删除策略和内存淘汰策略"></a>过期删除策略和内存淘汰策略</h2><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>redis 可以对 key 设置过期时间，相对应的机制将过期的键值对删除，这个机制就是过期键值删除策略</p><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><p>一般使用 <code>expire &lt;key&gt; &lt;n&gt;</code> ， 表示 key 在 n 秒后过期</p><p>也可以在创建时对 key 设置过期时间 <code>set &lt;key&gt; &lt;value&gt; ex &lt;n&gt; </code> 或 <code>setex &lt;key&gt; &lt;n&gt; &lt;value&gt;</code> ，表示设置键值对时，同时设置过期时间(单位 <code>秒</code> )</p><p>如果想查看某个 key 剩余存活时间，可以使用 <code>TTL &lt;key&gt;</code> 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置键值对，同时指定过期时间 60 秒</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">setex key1 60 value1</span></span><br><span class="line">ok</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 key1 过期时间</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ttl key1</span></span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure><p>如果反悔，取消 key 的过期时间，可以用 <code>persist &lt;key&gt;</code> 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消 key1 的过期时间</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">persist key1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 key1 过期时间</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-1 则表明永不过期</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ttl key1</span></span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><h4 id="Redis-如何判定过期"><a href="#Redis-如何判定过期" class="headerlink" title="Redis 如何判定过期"></a>Redis 如何判定过期</h4><p>当我们设置过期时间时， redis 会把该 key 带上过期时间存储到一个 <code>过期字典</code> 里<br>(实际上时 哈希表 ，时间复杂度 O(1))</p><h4 id="过期删除策略-1"><a href="#过期删除策略-1" class="headerlink" title="过期删除策略"></a>过期删除策略</h4><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><p>定期删除： <code>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达，由该事件处理器自动执行 key 的删除</code></p><p>惰性删除： <code>不主动删除过期 key ， 每次从数据库访问时进行检测，如果过期则删除 key</code></p><p>定时删除： <code>每隔一段时间 [随机(默认20个)] 从数据库取出一定量的 key 进行检查，并删除其中的 过期 key</code></p><h4 id="redis-过期删除策略"><a href="#redis-过期删除策略" class="headerlink" title="redis 过期删除策略"></a>redis 过期删除策略</h4><p>Redis 选择 <code>[惰性删除 + 定期删除]</code> 配合使用</p><p>惰性删除：  对访问的 key 判断是否过期，如果过期删除 key ，并且返回 null</p><p>定期删除： redis 默认每秒进行 10 次过期检查，通过 <code>redis.conf.hz</code> 进行设置；默认每次抽取 20 个 key，检查并删除过期的 key；如果本轮过期的数量超过 25% ，则重复执行，直至过期的 key 小于 25%，则停止继续删除过期 key ， 等待下一轮检查</p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>过期删除策略是删除过期的 key ，而 Redis 内存淘汰策略是 <code>当 Redis 运行内存超过 Redis 设置的最大内存后，用内存淘汰策略删除符合条件的 key</code> ， 以此来保障 Redis 高效运行</p><h4 id="如何设置-Redis-最大运行内存"><a href="#如何设置-Redis-最大运行内存" class="headerlink" title="如何设置 Redis 最大运行内存"></a>如何设置 Redis 最大运行内存</h4><p>在 redis.conf 中，通过参数 <code>maxmemory &lt;bytes&gt;</code> 来设置</p><ul><li>在 64 位操作系统中，这个默认值为 <code>0</code> ，表示没有内存大小限制</li><li>在 32 位操作系统中，这个默认值为 <code>3GB</code>，因为 32 位的机器最大支持 4GB 内存</li></ul><h4 id="Redis-内存淘汰策略"><a href="#Redis-内存淘汰策略" class="headerlink" title="Redis 内存淘汰策略"></a>Redis 内存淘汰策略</h4><ol><li>不进行数据淘汰策略<ul><li>noevication(redis3.0后， <code>默认的内存淘汰策略</code>)：不进行数据淘汰，拒绝写入</li></ul></li><li>进行数据淘汰<ul><li>volatile-random：随机淘汰，只淘汰设置了 <code>expire</code> 的 key</li><li>volatile-ttl：优先淘汰更早过期的 key</li><li>volatile-lru：淘汰所有设置了过期时间中，最久未使用的 key</li><li>volatile-lfu：淘汰所有设置了过期时间中，最少使用的 key</li><li>allkeys-random：随机淘汰</li><li>allkeys-lru：淘汰整个 key 中最久未使用的</li><li>allkeys-lfu：淘汰整个 key 中最少使用的</li></ul></li></ol><p>使用 <code>config get maxmemory-policy</code> 查看当前内存淘汰策略</p><p>设置内存淘汰策略方式</p><ol><li>通过命令 <code>config set maxmemory-policy &lt;策略&gt;</code> 设置</li><li>通过 redis.conf 设置 <code>maxmemory-policy &lt;策略&gt;</code></li></ol><h4 id="LRU-和-LFU"><a href="#LRU-和-LFU" class="headerlink" title="LRU 和 LFU"></a>LRU 和 LFU</h4><p>LRU：Least Recently Used， <code>最久未使用</code> ， 维护一个额外字段，记录此数据最后一次访问时间； <code>无法解决缓存污染</code></p><p>LFU：Least Frequently Used，<code>使用频率最少</code> ，记录使用次数</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>todo </p>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网</title>
      <link href="/posts/learn/%E8%AE%A1%E7%BD%91/"/>
      <url>/posts/learn/%E8%AE%A1%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>相关点</p><h2 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h2><ol><li><p>应用层(application)<br> 最上层，应用软件都在应用层实现。<br> 应用层 <code>专注于为用户提供应用功能</code> ，比如 <code>HTTP</code> 、 <code>DNS</code>等</p></li><li><p>传输层(Transport)<br> 传输层有两个协议：<code>TCP</code> 和 <code>UDP</code><br> <code>TCP</code> 的全程叫 传输控制协议(Transmission Control Protocol) ， 大部分使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。 TCP比UDP多了很多特性，比如 <code>可靠传输</code> 、 <code>流量控制</code> 、 <code>拥塞控制</code> 等。</p><p> <code>UDP</code> 的全称叫 用户数据包协议(User Datagram Protocol)。 UDP简单到 <code>只负责发送数据包，不保证是否抵达</code>。但实时性相对更好，传续效率高。 <code>UDP也可以实现可靠传输，把 TCP 达到特性在应用层实现</code>。</p></li></ol><p>应用层传输的数据可能很大，如果直接传输就不好控制，因此当传输层的数据包大小超过 <code>MSS(TCP最大保本段长度)</code> ，就要将数据包分块，这样即使途中有数据包丢失，只需要重新传送这一个分块。在 TCP 协议中，每个分块成为一个 <code>TCP段(TCP Segment)</code> </p><p><code>传输层携带端口，识别该报文发送给哪个应用</code></p><ol start="3"><li>网络层(Network)<br>网络层负责<code>实际的传输功能</code><br>网络层最常使用的 <code>IP 协议</code> ，IP 协议将传输层的报文作为数据部分，加上 <code>IP包头</code> 组成 IP 报文，如果 IP 报文大小超过 <code>MTU(一般为1500字节)</code> 就会再次进行 <code>分片</code> ，得到一个即将发送到网络的 IP 报文。</li></ol><p><code>IP协议的寻址作用告诉我们去往下一个目的地该朝哪个方向走，路由则是根据[下一个目的地]选择路径。寻址更像导航，路由更像操作方向盘</code></p><ol start="4"><li>网络接口层(Link)<br>在接收到 IP 报文后，交给 网络接口层在 IP 头部的前面加上 MAC 头部，并封装成 <code>数据帧</code> 发送到网络。<br>MAC 头部是以太网使用的额头不，包含接收方和发送方的 MAC地址等信息。通过 ARP 协议获取对方的 MAC 地址。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>应用层：负责向用户提供应用程序</li><li>传输层：对应用层数据进行分组和重组，并以TCP或UDP协议格式封装报文。</li><li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li><li>链路层：负责封装和解封 IP 报文，发送和接收ARP&#x2F;RARP报文等。</li></ul><p>OSI七层模型为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。由于复杂并没有广泛使用。</p><h2 id="键入网址流程"><a href="#键入网址流程" class="headerlink" title="键入网址流程"></a>键入网址流程</h2><p>todo…</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 是超文本传输协议，也就是<code>H</code> yper <code>T</code> ext <code>T</code> ransfer <code>P</code> rotocol</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>1xx：提示信息，表示正在处理</li><li>2xx：成功</li><li>3xx：重定向</li><li>4xx：客户端错误</li><li>5xx：服务器错误</li></ul><h3 id="HTTP-常见字段"><a href="#HTTP-常见字段" class="headerlink" title="HTTP 常见字段"></a>HTTP 常见字段</h3><ul><li><code>Host</code> 字段：用来指定服务器域名</li><li><code>Content-Type</code> 字段：用来指定请求或响应的数据类型</li><li><code>Connection</code> 字段：用来指定是否为长连接</li></ul><h3 id="GET-和-POST"><a href="#GET-和-POST" class="headerlink" title="GET 和 POST"></a>GET 和 POST</h3><ul><li><code>GET 方法就是安全且幂等的</code> ， 因为它是 [只读] 操作， <code>可以对 GET 请求的数据做缓存，可以做到服务器本身上，也可以做到代理上(如Nginx)，而且在浏览器中 GET请求可以保存为书签。</code></li><li><code>POST</code> 因为要提交数据，所以是 <code>不安全的</code> ，且多次提交数据就会创建多个资源，所以不是 <code>幂等</code> 的。 <code>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</code>。</li></ul><h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p>对于一些具有重复性的请求，可以对 [请求-响应] 的数据都 <code>缓存在本地</code>，那么下次直接读取，不必获取服务器响应。</p><p>缓存实现方式：<code>强制缓存</code> 和 <code>协商缓存</code>。</p><ul><li>强制缓存：服务器在响应头中设置 <code>Cache-Control</code> 字段，设置 <code>max-age</code> 或者 <code>Expires</code> 字段，浏览器会根据这些字段判断是否需要缓存。</li><li>协商缓存：基于 <code>时间</code> 或 <code>标识</code> 来实现。 服务器在响应头中设置 <code>Last-Modified(这个相应资源的最后修改时间)</code> 或者 <code>Etag(唯一标识响应资源)</code> 字段，浏览器会根据这些字段判断是否需要缓存。 如果两个字段都有， <code>Etag</code> 的优先级更高。<br>注：<code>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</code></li></ul><h3 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h3><p>HTTP&#x2F;1.1<br><code>无状态</code> 和 <code>明文传输</code> 既是优点也是缺点</p><ul><li><code>无状态</code> 表明服务器不会保存客户端的状态，服务器资源能利用更加高效。但缺点就是服务器没有记忆能力，<code>每次请求都需要对身份进行确认。</code></li><li><code>明文传输</code> 方便阅读，方便进行调试，但缺点是安全性低。</li></ul><p>HTTP 的安全问题，可以用 HTTPS 的方式解决，通过引入 <code>SSL/TLS</code> 层使得在安全上达到了极致。</p><h3 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h3><p> HTTP 基于 <code>TCP/IP</code> ，并且使用了 [请求-应答] 的通信模式，所以性能的关键在于：</p><ul><li>长连接<br>HTTP&#x2F;1.0 默认不支持长连接，每一次请求都要新建 TCP连接，性能差，而 HTTP&#x2F;1.1 提出了长连接， <code>减少了重复简历连接的开销</code></li><li>管道网络传输<br>HTTP&#x2F;1.1 默认支持管道网络传输， <code>可以同时发送多个请求，减少请求等待时间。但服务器必须按照接收请求的顺序发送对这些管道请求的响应</code><br>这就有个问题： <code>HTTP/1.1解决了请求的队头阻塞，但是没有解决响应的对头阻塞</code>。</li></ul><h3 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h3><ul><li>HTTP 是超文本传输协议，信息明文传输，不安全。HTTPS 是 HTTP 的安全版本，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文加密传输。</li><li>HTTP建立连接相对简单， TCP 三次握手就可以；而 HTTPS 还需要进行 SSL&#x2F;TLS 的握手过程。</li><li>HTTP 默认端口 <code>80</code> ， HTTPS 默认端口 <code>443</code>。</li><li>HTTPS协议要向 CA(证书权威机构) 申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="HTTPS-解决-HTTP-风险"><a href="#HTTPS-解决-HTTP-风险" class="headerlink" title="HTTPS 解决 HTTP 风险"></a>HTTPS 解决 HTTP 风险</h3><ul><li>信息加密: 交互信息无法窃取</li><li>校验机制: 无法篡改通信内容</li><li>身份证书: 服务器端证书，证明真伪</li></ul><p>解决方法</p><ul><li><code>混合加密</code> 实现信息的 <code>机密性</code></li><li><code>摘要算法</code> 实现完整性，为数据生成独一无二的 [指纹] ，用来校验数据完整性</li><li>将服务器公钥放入 <code>数字证书</code> 解决冒充</li></ul><ol><li><code>混合加密</code></li></ol><p>HTTPS 采用 <code>对称加密</code> 和 <code>非对称加密</code> 结合的 [混合加密]</p><ul><li>在通信建立前采用 <code>非对称加密</code> 交换 [会话密钥] ，后续不再使用非对称加密</li><li>在通信过程中全部使用 <code>对称加密</code> 的方式加密明文数据</li></ul><p>采用 [混合加密] 原因：</p><ul><li><code>对称加密</code> 只有一个密钥，运算速度快，密钥需保密，无法做到安全的交换</li><li><code>非对称加密</code> 使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了交换问题但速度慢。</li></ul><ol start="2"><li><code>摘要算法 + 数字签名</code></li></ol><p>为保证传输内容不被篡改，需对内容计算出一个 [指纹] ，然后同内容一起传输给对方；收到后先对内容计算一个 [指纹] ，然后跟发送方传输的 [指纹] 进行比较，如果不相同，则认为内容被篡改。</p><p>那么，<code>摘要算法(哈希函数) 来计算出内容的哈希值</code>，也就是 [指纹] ，<code>哈希值是唯一的，且无法通过哈希值推导出内容</code></p><p>通过哈希算法可以确保内容不被篡改， <code>但是不能保证 [内容 + 哈希值] 不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。</code></p><p>计算机会用 <code>非对称加密算法</code> 解决。通过 [私钥加密，公钥解密] 的方式，确认消息身份，也就是 <code>数字签名算法</code>，加密的内容不是内容本身，而是 <code>对内容的哈希值加密</code> 。</p><ol start="3"><li><code>数字证书</code></li></ol><p>服务器把公钥注册到数字证书认证机构中， <code>数字证书认证机构会颁发一个数字证书</code> ，这个证书中包含了公钥，以及一些其他信息，比如服务器的域名，过期时间等。<br>客户端拿到服务器的数字证书使用CA的公钥确认服务器的数字证书真实性，从数字证书获取服务器公钥对报文加密后发送，服务器再用私钥进行解密。这样就安全了。</p><h3 id="HTTP-1-1-相比-HTTP-1-0"><a href="#HTTP-1-1-相比-HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0</h3><p>改进</p><ul><li>使用 <code>长连接</code></li><li>支持 管道 网络传输，只要第一个请求发送了，不必等其回来，就可以发送第二个</li></ul><p>瓶颈</p><ul><li>请求&#x2F;响应头未经压缩就发送，首部信息越多延迟越大</li><li>发送冗长的首部。每次发送相同的首部造成的浪费较多</li><li>服务器按请求的顺序响应，造成 <code>响应对头阻塞</code></li><li>没有请求优先级控制</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h3 id="HTTP-2-的优化"><a href="#HTTP-2-的优化" class="headerlink" title="HTTP&#x2F;2 的优化"></a>HTTP&#x2F;2 的优化</h3><ul><li><p>头部压缩<br>如果同时发出多个请求，他们的头是一样的或相似的，协议会帮助 <code>消除重复部分</code><br>基于 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头部信息表，所有字段都会存入这个表，生成一个索引号，以后不会发送同样字段，只发送索引号，减少头部信息</p></li><li><p>二进制格式<br>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里纯文本的报文形式，全面采用 <code>二进制格式</code> ，头部信息和数据体都是二进制，并且统称为帧： <code>头信息帧</code>、 <code>数据帧</code>。<br>这样对计算机非常友好，计算机不用解析，增加数据传输效率</p></li><li><p>并发传输<br>引入 Stream 概念，多个 Stream复用在一条 TCP 连接上<br><code>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID有序组装 HTTP 消息，不同 Stream 的帧可以乱序发送，因此可以并发不同的 Stream， HTTP/2 可以并行交错地发送请求和响应</code></p></li><li><p>服务器推送<br>HTTP&#x2F;2 中服务器不再被动地响应，可以 <code>主动</code> 向客户端发送消息。<br>客户端和服务器 <code>双方都可以建立 Stream</code> ， <code>客户端建立的是 奇数号</code> ， <code>服务器建立的是偶数号</code>。</p></li></ul><p>HTTP&#x2F;2的缺陷<br>解决了 HTTP&#x2F;1 队头阻塞， <code>但响应对头阻塞问题仍然存在。</code></p><p><code>HTTP/2 是基于 TCP协议来传输数的， TCP 是字节流协议， TCP层必须保证收到的字节流是完整的且连续的，这样内核才会将缓冲区的数据返回给 HTTP 应用，那么当 [前1个字节数据] 没到达时， 后面收到的只能存放在内核缓冲区，等这1个字节数据到达时，内核才会返回给应用层，应用层才能处理。 这就是 HTTP/2 队头阻塞</code></p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><p>TCP 是 <code>面向连接的、可靠的、基于字节流</code> 的传输层通信协议。</p><p>TCP 头的格式<br><img src="/img/learn/tcp-header.png" alt="TCP 头"></p><p>TCP 连接是需要客户端与服务端达成三个信息共识</p><ul><li>Socket：由 IP 地址和端口号组成</li><li>序列号：用来解决乱序问题</li><li>窗口大小：用来做流量控制</li></ul><p>最大 TCP 连接数 &#x3D; 客户端IP数 ✖ 客户端的端口数</p><h3 id="UDP-和-TCP-有什么区别"><a href="#UDP-和-TCP-有什么区别" class="headerlink" title="UDP 和 TCP 有什么区别"></a>UDP 和 TCP 有什么区别</h3><p>UDP 协议非常简单，头部只有 <code>8</code> 个字节</p><ul><li>源端口和目标端口号(各16位)：告诉UDP发送给哪个进程</li><li>包长度(16位)：保存了 UDP 首部长度和数据长度之和</li><li>校验和(16位)：校验和为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传送中受损的 UDP 包</li></ul><p>区别</p><ol><li>连接</li></ol><ul><li>TCP 是 <code>面向连接的</code>，传输前需要建立连接</li><li>UDP 不需要连接</li></ul><ol start="2"><li>服务对象</li></ol><ul><li>TCP 是一对一两点服务</li><li>UDP 支持一对一、一对多、多对多</li></ul><ol start="3"><li>拥塞控制、流量控制</li></ol><ul><li>TCP 又拥塞控制和流量控制机制，保证数据传输安全性</li><li>UDP 则没有，即使网络拥堵，也不会影响 UDP 发送速率</li></ul><ol start="4"><li>首部开销</li></ol><ul><li>TCP 首部长度有一定开销，首部没有使用 [选项] 字段时是 <code>20</code> 字节，如果使用会更长</li><li>UDP 首部长度是固定的 <code>8</code> 字节</li></ul><ol start="5"><li>分片</li></ol><ul><li>TCP的数据大小超过 <code>MSS</code>，则会在传输层分片</li><li>UDP 的数据大小超过 <code>MTU</code>，则会在网络层分片</li></ul><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p>TCP 是面向连接的协议，所以使用 TCP 前必须建立连接，而 <code>建立连接时通过三次握手进行的</code></p><ol><li>客户端向服务器发送一个 <code>SYN报文</code> ，该报文初始化首部的[序列号]，同时把 <code>SYN</code> 标志位设置为1，表示发起连接。</li><li>服务器收到该报文后，如果允许连接，首先初始化自己的 [序列号] ，其次把 [确认应答号] 填入 <code>客户端的序列号 + 1</code>，接着把 <code>SYN</code> 和 <code>ACK</code> 标志位都设置为1，表示接受连接。</li><li>客户端收到服务器的报文后，初始化自己的 [确认应答号] ，然后把 [序列号] 填入 <code>服务器的序列号 + 1</code>，最后把 <code>ACK</code> 标志位设置为1，最后把报文发送给服务端，之后处于 <code>ESTABLISHED</code> 状态</li><li>服务端收到报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ol><p>在三次握手过程中，<code>第三次握手可以携带数据，前两次是不可以携带数据的</code></p><h4 id="为什么是三次握手，不是两次、四次？"><a href="#为什么是三次握手，不是两次、四次？" class="headerlink" title="为什么是三次握手，不是两次、四次？"></a>为什么是三次握手，不是两次、四次？</h4><ul><li>三次握手可以 <code>阻止重复历史连接的初始化</code> (主要原因)</li><li>同步双方初始化序列号</li><li>避免资源浪费</li></ul><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位为 <code>1</code> 的报文，即 <code>FIN报文</code> ，之后客户端进入 <code>FIN_WAIT_1</code> 状态</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接收服务端进入 <code>CLOSE_WAIT</code> 状态</li><li>等服务端处理完后就向 客户端发送 <code>FIN</code> 报文，即 <code>FIN</code> 报文，服务端进入 <code>LAST_ACK</code> 状态</li><li>客户端收到服务端 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，进入 <code>TIME_WAIT</code> 状态，<code>服务端收到 ACK 应答后，就进入 CLOSE 状态，客户端等待 2MSL (报文最大生存时间) ，进入 CLOSED 状态</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/posts/learn/mysql/"/>
      <url>/posts/learn/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>摘要，记录一些自己认为重要需要学习的。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。<br>INT(11) 中的<code>数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的</code>。  </p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><code>FLOAT</code> 和 <code>DOUBLE</code> 浮点类型，<code>DECIMAL</code> 为高精度小数类型。  </p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>主要有 <code>CHAR</code> 和 <code>VARCHAR</code> 两种类型，一种是定长的，一种是变长的。<br><code>VARCHAR</code> 会保留字符串末尾的空格， <code>char</code> 会删除  </p><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p><code>DATETIME</code> 和 <code>TIMESTAMP</code><br><code>DATETIME</code> 能够保存1001年到9999年时间，精度为秒，使用8字节存储。 <code>与时区无关</code><br><code>TIMESTAMP</code> 和UNIX时间戳相同，保存从1970年1月1日午夜以来的秒数，使用4个字节，只能表示从1970-2038年。 <code>与时区有关</code> 。  </p><h3 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h3><ul><li><code>更小</code> 的数据类型通常更快，<code>因为它占用更少磁盘、内存和CPU缓存，并且处理周期少</code>  </li><li><code>简单就好</code> 例如：整形比字符串操作代价更小  </li><li><code>避免使用NULL</code> 如果查询列包含NULL，对SQL来说优化更难，因为 <code>NULL使得索引、统计和值比较变得复杂， 尽量使索引包含的字段设置成 NOT NULL</code></li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>MySQL默认的 <code>事务型引擎</code> ，支持真正的 <code>在线热备份</code> 。  </p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。 <code>但在表有读取操作的同时，也可以往表中插入新的记录</code> ，这被称为并发插入(CONCURRENT INSERT)。  </p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li>事务：Innodb是事务型，可以使用 <code>Commit</code> 和 <code>Rollback</code></li><li>并发：MyISAM 只支持 表级锁 ， InnoDB支持 <code>行级锁(即锁一条数据)</code> 。</li><li>外键：InnoDB支持</li><li>备份： InnoDB支持在线热备份</li></ul><h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><p><code>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。</code> InnoDB存储引擎中默认每个页的大小为 <code>16KB</code> ，可通过参数 <code>innodb_page_size</code> 将页的大小设置为4K、8K、16K</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。<br>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。  </p><p><code>B Tree 和 B + Tree的最大区别</code>  </p><ul><li>B Tree每个节点都带有key和data，而 B + Tree <code>非叶子节点只有key</code>，所以<code>相同量的数据B + Tree更加矮胖，减少了检索次数，更加高效</code>。</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。 <code>插入删除操作记录会破坏平衡树的平衡性</code> ，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。<code>尽量减少插入或使键有序，也减少删除</code>  </p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li><code>对索引使用函数</code>  </li><li><code>OR 条件左边是索引右边不是索引</code>  </li><li><code>左模糊查询或者左右模糊查询</code>  </li><li><code>未满足最左前匹配</code>  </li><li><code>查询条件左边为字符串出现了隐式转换</code></li></ul><h3 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h3><ul><li>通过 <code>explain</code> 进行语法分析，分析key是否用了索引，rows扫描的行数等</li><li><code>尽量不要select *，返回必要的列</code>， <code>尽量用LIMIT限制返回的行</code>  </li><li><code>缓存重复查询的数据，可以避免重复查询数据库，还能提高查询效率</code></li><li><code>减少扫描行数，尽量使用覆盖索引</code>  </li><li>对大SQL进行分解,<code>因为一个大DML SQL会锁住很多数据，耗尽资源，阻塞很多小而重要的SQL</code>， 分解SQL<code>易于让缓存利用更加高效，在应用层进行连接，可以更容易对数据库进行拆分，从而更好做到高性能和可伸缩</code></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>读未提交(一个事务能<code>读到另外一个事务未提交的数据</code>)</li><li>读已提交(一个事务提交的数据能被其他事务读取)</li><li>可重复读(一个事务读取的数据和事务 <code>开启时保持一致</code> )  <code>InnoDB默认隔离级别</code>   </li><li>串行化(对记录进行 <code>加锁</code> ，如果多个事务发生 <code>读写冲突</code> ， <code>后访问的事务必须等前一个事务执行完成</code> 才能继续执行)</li></ul><h3 id="隔离级别的实现方式"><a href="#隔离级别的实现方式" class="headerlink" title="隔离级别的实现方式"></a>隔离级别的实现方式</h3><ul><li>对于[读未提交] 直接读取最新数据即可  </li><li>对于[串行化] ，通过加读写锁来避免并行访问</li><li>对于 [读已提交] 和 [可重复读] ，通过<code>Read View</code> 实现， <code>区别在于创建Read View的时机不同，Read View类似于数据快照，[读已提交]在[每个语句执行前]生成，而[可重复读]则是在[启动事务时]生成一个 Read View</code></li></ul><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h3><p>InnoDB引擎在[可重复读]隔离级别下，<code>很大程度上避免了幻读</code> </p><ul><li>针对 <code>快照读</code>(普通select语句)，<code>通过 MVCC 方式解决幻读</code><br>· 快照读是 <code>不加锁读，基于MVCC实现的，当隔离级别是可串行化时，会自动退化成当前读</code></li><li>针对<code>当前读</code>(select.. for update) <code>通过next-key lock(记录锁+间隙锁)方式解决幻读</code><br>· 当前读是指读取最新数据，读取保证其他并发事务不能修改当前记录， <code>会对读取数据进行加锁</code></li></ul><h3 id="Read-View在MVCC中的工作"><a href="#Read-View在MVCC中的工作" class="headerlink" title="Read View在MVCC中的工作"></a>Read View在MVCC中的工作</h3><p>Read View中的四个字段可以把事务分为 <code>已经提交的事务</code>、 <code>当前事务id</code> 、<code>创建Read View时，当前活跃且未提交事务的id范围</code>以及 <code>还未开始的事务</code><br>聚簇索引中包含两个隐藏字段 <code>对该行更改的事务trx_id</code> 和 <code>指向旧版本的指针，旧版本的记录写入到 undo 日志中</code>  </p><p>一个事务对记录进行访问时，会将 <code>trx_id在Read View中进行比较</code>  </p><ul><li>如果 <code>trx_id小于最小活跃事务id</code> ,则表示该版本是在创建此Read View之前已经提交了的版本，因此可见  </li><li>如果 <code>trx_id大于等于还未开始事务的id</code> ,则表示该记录版本是  <code>在创建该Read View后启动事务更改的，所以该版本不可见</code>  </li><li>如果 <code>trx_id在上述情况之间，则需判断是否在活跃且未提交事务id范围中</code><br>· 如果trx_id<code>在已启动且未提交事务范围中，则表明生成该版本的事务还在活跃，所以该版本不可见</code><br>· 如果trx_id<code>不在已启动且未提交事务范围中，则表明生成该版本的事务已经提交，所以该版本可见</code>  </li><li>虽然MVCC只是很大程度避免了幻读， <code>但还是存在幻读</code> ，比如 <code>事务A更新了一条事务B插入的记录，那么事务A前后两次查询的记录就不一样了</code></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>MySQL加锁可以分为 <code>全局锁</code> 、 <code>表锁</code> 、 <code>行锁</code> 三类</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul><li>元数据锁<br>· 对一张表进行CRUD时，会自动加 <code>MDL 读锁</code><br>· 对一张表进行结构变化时，会自动加 <code>MDL 写锁</code></li></ul><p>MDL锁是为了保证当前用户进行操作时，防止其他线程对这个表结构进行更改。<code>写锁优先级高于读锁</code></p><ul><li><p>意向锁</p></li><li><p>AUTO-INC锁<br>表主键为自增时，<code>在新增数据时，会持有该锁，在新增完成后就会释放。</code></p></li></ul><p>Innodb提供了一种轻量锁，<code>给自增字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</code></p><h3 id="行级锁种类"><a href="#行级锁种类" class="headerlink" title="行级锁种类"></a>行级锁种类</h3><ul><li><p>记录锁(锁住一条记录)<br>· 当事务当前读查询获取到该记录的记录锁， <code>其他事务对该记录的更新和删除会发生阻塞</code>，如果其他事务进行插入不会阻塞，因为会报错主键重复</p></li><li><p>间隙锁(锁住一个范围，<code>左开有开区间</code>)<br>·  <code>只存在于可重复读级别，目的是为了解决可重复读的幻读</code><br>· <code>两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥，因为间隙锁目的是为了防止插入幻影记录</code> </p></li><li><p>next-key lock锁(记录锁和间隙锁的组合， <code>左开右闭区间</code>)</p></li></ul><h3 id="针对当前读加锁"><a href="#针对当前读加锁" class="headerlink" title="针对当前读加锁"></a>针对当前读加锁</h3><h3 id="MySQL如何加锁"><a href="#MySQL如何加锁" class="headerlink" title="MySQL如何加锁"></a>MySQL如何加锁</h3><p>加锁的对象是 <code>索引</code>，加锁的基本单位是<code>next-key lock，左开右闭区间</code>  </p><p>在某些情况下，如果使用记录锁或间隙锁就足以防止幻读现象的发生，那么next-key lock就会退化成记录锁或间隙锁。  </p><ul><li><p>当我们用 <code>主键索引进行等值查询</code> ，<code>如果记录存在，则退化成 [记录锁] ， 如果记录不存在，则退化成 [间隙锁] </code>  </p></li><li><p>当我们用<code>主键索引进行范围查询时</code>，会对每一个扫描到的索引加next-lock锁<br>· 针对<code>大于等于</code>，因为存在等值，所以对扫描到的记录<code>退化成记录锁</code><br>· 针对<code>小于等于或者小于</code>，  <code>取决于条件值的记录是否存在</code><br>· 如果<code>记录在表中不存在</code> ， <code>扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化成间隙锁</code>，其他扫描到的记录加next-key锁<br>· 当查询 <code>记录在表中存在</code> ，如果是 <code>小于条件</code> ， <code>扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化成间隙锁</code> ，其他为next-lock锁   </p></li><li><p>当我们用<code>非主键索引进行等值查询时</code> ， <code>因为存在两个索引，一个是主键索引，一个是二级索引，所以在加锁时，同时会对这两个索引加锁，但对主键索引加锁时，只有满足查询条件的记录才会对它们的主键索引加锁</code><br>· 当 <code>查询的记录存在</code> 时，<code>会进行二级索引扫描，直到扫描到第一个不符合条件的记录就停止，然后对扫描到的二级索引添加 next-lock锁 ，而对于第一个不符合条件的索引退化成间隙锁，同时在符合条件的记录的主键索引添加记录锁</code><br>· 当 <code>查询记录不存在</code> 时，扫描到第一个不符合条件的二级索引记录，该二级索引的next-key锁会退化成间隙锁。因为不满足查询条件，所以<code>不会对主键索引加锁</code>  </p></li><li><p>当我们用<code>非主键索引进行范围查询时，索引的next-lock 锁不会退化！！！</code></p></li></ul><h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><ol><li><p>连接器<br>· 首先经过连接器进行连接，先经过 <code>TCP</code> 三次握手建立连接后， <code>验证账号密码</code> ,通过则建立长连接</p></li><li><p>查询缓存(8.0将这一部分删掉)<br>· 如果有这一步则进行查询看是否执行过这一条语句，缓存以key-value形式存储，key为查询语句  </p></li><li><p>解析器-解析SQL<br>· 进行 <code>词法分析</code>获取关键字 ， <code>语法分析</code>  判断SQL满足规则，建立SQL语法树。</p></li><li><p>执行SQL<br>· <code>预处理器</code> 检查字段是否存在，将*扩展为所有列<br>· <code>优化器</code> 负责将语句的执行方案确定下来，基于内部的选择来决定走哪个索引等<br>· <code>执行器</code> 与存储引擎进行交互</p></li></ol><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="undo-log-回滚日志-实现事务中的原子性，用于事务-回滚-和-MVCC"><a href="#undo-log-回滚日志-实现事务中的原子性，用于事务-回滚-和-MVCC" class="headerlink" title="undo log(回滚日志) 实现事务中的原子性，用于事务 回滚 和 MVCC"></a>undo log(回滚日志) 实现事务中的原子性，用于事务 回滚 和 MVCC</h3><ul><li>在 <code>插入</code> 一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录 <code>删掉</code> 就好了；</li><li>在 <code>删除</code> 一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录 <code>插入</code> 到表中就好了；</li><li>在 <code>更新</code> 一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列 <code>更新为旧值</code> 就好了。</li></ul><h3 id="redo-log-重做日志-实现事务中的持久化，用于掉电等故障恢复"><a href="#redo-log-重做日志-实现事务中的持久化，用于掉电等故障恢复" class="headerlink" title="redo log(重做日志) 实现事务中的持久化，用于掉电等故障恢复"></a>redo log(重做日志) 实现事务中的持久化，用于掉电等故障恢复</h3><p>Buffer Pool会把存储的数据划分为若干个页，默认 <code>16KB</code> ，叫做 <code>缓存页</code></p><p>Buffer Pool 是为了提高读写效率，但它是基于内存，内存不可靠。</p><p>为了防止断电等导致数据丢失，当记录一条数据时， Innodb 会先更新内存(同时标记为 <code>脏页</code> )，会在合适的时机，由后台线程将缓存在 Buffer Pool 中的数据刷到磁盘上，这就是 <code>WAL 技术</code></p><p>redo log 和 undo log的区别</p><ul><li>redo log 记录了此次事务 <code>完成后</code> 的数据状态，记录的是更新 <code>之后</code> 的新值</li><li>undo log 记录此次事务 <code>开始时</code> 的数据状态，记录的是 <code>之前 </code>的旧值<br>事务提交之前发生崩溃，通过undo log 进行回滚数据，事务提交后发生崩溃，通过 redo log 进行恢复<br>redo log 是追加方式，所以是[顺序写]入磁盘；而写入数据是[随机写]。这就好比一个记事本按顺序一直往下写和写一个字要找对应的页。<br>redo log 实现了 <code>事务的持久性，让 MySQL 有了崩溃恢复的能力</code>， <code>将写操作从[随机写]转变为[顺序写]，提升写入磁盘性能</code>。</li></ul><p>产生的 redo log 也 <code>不是直接写入磁盘</code> ，因为这样产生大量 I&#x2F;O 效率低下</p><p>redo log 有自己的缓存- <code>redo log buffer</code><br>写入时机：</p><ul><li>MySQL 正常关机</li><li>当 redo log buffer 写入量超过 <code>1/2</code> 时，将 redo log buffer 写入磁盘</li><li>Innodb 后台线程每隔一秒，持久化一次</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</li></ul><p>redo log 实际是由两个 log 文件(一个大小默认为 1GB )组成，两个文件循环写， <code>当redo log写的 Buffer Pool 脏数据超过redo log大小，即 redo log 写满后</code> ，就会阻塞 MySQL ，此时 <code>会停下来将 Buffer Pool 中的脏数据刷新到磁盘中，然后标记 redo log 哪些可以删除，接着对旧的 redo log 进行擦除，腾出空间，然后 MySQL 恢复正常</code></p><h3 id="bin-log-归档日志-主要用于数据备份和主从复制"><a href="#bin-log-归档日志-主要用于数据备份和主从复制" class="headerlink" title="bin log(归档日志) 主要用于数据备份和主从复制"></a>bin log(归档日志) 主要用于数据备份和主从复制</h3><p>MySQL 执行完一条更新操作后，还会生成一条 binlog，等事务提交后，会将该事务产生的 binlog统一写入 binlog 文件。</p><p>binlog 主要记录所有数据库表结构变更和表数据修改的日志， <code>不会记录查询类的操作</code></p><h4 id="redo-log-和-binlog区别"><a href="#redo-log-和-binlog区别" class="headerlink" title="redo log 和 binlog区别"></a>redo log 和 binlog区别</h4><ol><li>适用范围不同<ul><li>binlog是 MySQL 的 Server 层实现的，任何存储引擎都可以使用</li><li>redo log 是 Innodb 存储引擎实现的日志</li></ul></li><li>文件格式不一样<ul><li>binlog 有三种格式类型：STATEMENT、 ROW、MIXED<ul><li>STATEMENT：<code>记录的是SQL语句</code> ，相当于逻辑日志；但有 <code>动态函数问题</code> ，比如用了 uuid 或 now 函数，在主库上执行的结果并不是在从库上执行的结果，这种随时在变的函数会导致数据复制不一致。</li><li>ROW：<code>记录的是数据变更</code> ，每行数据变化的结果都会记录，使 binlog 文件过大</li><li>MIXED: <code>STATEMENT + ROW</code> 模式，会根据不同情况使用</li></ul></li><li>redo log是物理日志，记录某个数据页的修改，比如对XX表空间中的YY数据页ZZ偏移量的地方AAA更新</li></ul></li><li>写入方式<ul><li>binlog 是追加写，写满之后新建</li><li>redo log 是循环写，日志空间固定</li></ul></li><li>用途不一样<ul><li>binlog 是数据备份、主从复制</li><li>redo log 掉电等故障恢复</li></ul></li></ol><h4 id="主从复制模型"><a href="#主从复制模型" class="headerlink" title="主从复制模型"></a>主从复制模型</h4><ul><li>同步复制: MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回结果。</li><li>异步复制(默认): MySQL 主库提交事务的线程不等待从库复制成功，直接返回。</li><li>半同步复制：MySQL 5.7 版本之后新增的方式，事务不用等待所有从库复制成功响应， <code>只用返回一部分复制成功响应即可</code>。半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。</li></ul><p>当一个事务提交后，其 <code>产生的 binlog 先写入 binlog cache </code> ，每个线程都有一个。</p><p>binlog 刷盘是根据参数 <code>sync_binlog</code> 来控制的</p><ul><li><code>sync_binlog=0</code>: 每次提交事务只 write，不fsync，后续由系统决定</li><li><code>sync_binlog=1</code>: 每次提交事务都 write 和 fsync</li><li><code>sync_binlog=N</code>: N 次 write 后，执行 fsync</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12306(一)</title>
      <link href="/posts/12306/12306(%E4%B8%80)/"/>
      <url>/posts/12306/12306(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>本项目为<a href="https://github.com/Wangbangc/12306">开源项目</a></p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>先了解相关包，对项目有个整体的了解。<br><img src="/img/12306/package.png" alt="包相关说明" /></p><p>配置相关看 <a href="https://nageoffer.com/12306/environment-configuration/">官方环境搭建</a> 就行了</p><h1 id="站点查询相关"><a href="#站点查询相关" class="headerlink" title="站点查询相关"></a>站点查询相关</h1><p>因为 <code>查询大多都类似</code> ，比较复杂的就是首页进行车票查询，所以再这里只写一个</p><p>接口 <code>/api/ticket-service/ticket/query</code> ，查询车票(默认访问查询 <code>北京到杭州的车票</code> )访问首页即可触发</p><p>大致流程: 请求首先会在网关中被拦截，然后通过黑白名单进行过滤，请求再到相应服务端进行处理，对于上述车票的查询，<code>网关路由到服务端后首先查询缓存，查询不到就查询数据库，并将相关数据存储在缓存中</code>。</p><p>具体流程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端接口</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api/ticket-service/ticket/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;TicketPageQueryRespDTO&gt; pageListTicketQuery</span><br><span class="line"><span class="comment">// 参数为 两站台缩写</span></span><br><span class="line">(TicketPageQueryReqDTO requestParam) &#123;</span><br><span class="line">    <span class="keyword">return</span> Results.success(</span><br><span class="line">        ticketService.pageListTicketQueryV1(requestParam));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到实现层后，第一行代码就是利用 <code>责任链模式</code>，首先 <code>对参数进行校验</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 责任链模式 验证城市名称是否存在、不存在加载缓存以及出发日期不能小于当前日期等等</span></span><br><span class="line">ticketPageQueryAbstractChainContext.handler</span><br><span class="line"><span class="comment">// 第一个参数是标记，用于区分不同的责任链</span></span><br><span class="line"><span class="comment">// 第二个是要进行校验的参数</span></span><br><span class="line">(TicketChainMarkEnum.TRAIN_QUERY_FILTER.name(), requestParam);</span><br></pre></td></tr></table></figure><p>再进入到 <code>ticketPageQueryAbstractChainContext</code> 时，首先我们要看一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个单接口， <code>文中用了大量的 @FunctionalInterface 来标识接口，我能想到的目的就是规范开发， 只定义一个接口增加灵活性，方便扩展 ? </code></p><p>接下来再进入 <code>ticketPageQueryAbstractChainContext</code> 查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AbstractChainContext</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;AbstractChainHandler&gt;&gt; abstractChainHandlerContainer </span><br><span class="line">    = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 责任链组件执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mark         责任链组件标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestParam 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(String mark, T requestParam)</span> &#123;</span><br><span class="line">        List&lt;AbstractChainHandler&gt; abstractChainHandlers </span><br><span class="line">        = abstractChainHandlerContainer.get(mark);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(abstractChainHandlers)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String</span><br><span class="line">            .format(<span class="string">&quot;[%s] Chain of Responsibility ID is undefined.&quot;</span>, mark));</span><br><span class="line">        &#125;</span><br><span class="line">        abstractChainHandlers.</span><br><span class="line">        forEach(each -&gt; each.handler(requestParam));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在初始化时就进行装载， 我给忘了在哪里加载来着。chao TODO</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;String, AbstractChainHandler&gt; chainFilterMap = ApplicationContextHolder</span><br><span class="line">                .getBeansOfType(AbstractChainHandler.class);</span><br><span class="line">        chainFilterMap.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">            List&lt;AbstractChainHandler&gt; abstractChainHandlers = </span><br><span class="line">            abstractChainHandlerContainer.get(bean.mark());</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(abstractChainHandlers)) &#123;</span><br><span class="line">                abstractChainHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            abstractChainHandlers.add(bean);</span><br><span class="line">            List&lt;AbstractChainHandler&gt; actualAbstractChainHandlers = </span><br><span class="line">            abstractChainHandlers.stream()</span><br><span class="line">                    .sorted(Comparator.comparing(Ordered::getOrder))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">            abstractChainHandlerContainer.put(bean.mark(), actualAbstractChainHandlers);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述最重要的是 <code>abstractChainHandlers.forEach(each -&gt; each.handler(requestParam));</code><br>将参数依次传到责任链进行相关校验</p><p><code>之后基本上都是查询数据库写入缓存的操作，我只写逻辑，没怎么给注释</code> </p><p><code>感觉代码很美</code>，可以多看看写法，很帅</p><p>校验完成后尝试从 Redis 缓存中进行获取两地信息，如果获取不到就加锁用 <code>双重校验锁(锁前查询一次，锁后再查询一次)</code> 进行 数据库获取 <code>所有站台缩写与城市之间的映射关系</code> 查询并插入 缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; stationDetails = stringRedisTemplate.opsForHash()</span><br><span class="line">        .multiGet(REGION_TRAIN_STATION_MAPPING,</span><br><span class="line">                Lists.newArrayList(requestParam.getFromStation(), requestParam.getToStation()));</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stationDetails.stream().filter(Objects::isNull).count();</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(LOCK_REGION_TRAIN_STATION_MAPPING);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stationDetails = stringRedisTemplate.opsForHash()</span><br><span class="line">                .multiGet(REGION_TRAIN_STATION_MAPPING, Lists.newArrayList(requestParam.getFromStation(), requestParam.getToStation()));</span><br><span class="line">        count = stationDetails.stream().filter(Objects::isNull).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;StationDO&gt; stationDOList = stationMapper.selectList(Wrappers.emptyWrapper());</span><br><span class="line">            Map&lt;String, String&gt; regionTrainStationMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            stationDOList.forEach(each -&gt; regionTrainStationMap.put(each.getCode(), each.getRegionName()));</span><br><span class="line">            stringRedisTemplate.opsForHash().putAll(REGION_TRAIN_STATION_MAPPING, regionTrainStationMap);</span><br><span class="line">            stationDetails = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            stationDetails.add(regionTrainStationMap.get(requestParam.getFromStation()));</span><br><span class="line">            stationDetails.add(regionTrainStationMap.get(requestParam.getToStation()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到数据后，再通过同样的方式，获取到 <code>所有北京到杭州站点的车票</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TicketListDTO&gt; seatResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">buildRegionTrainStationHashKey</span> <span class="operator">=</span> String.format(REGION_TRAIN_STATION, stationDetails.get(<span class="number">0</span>), stationDetails.get(<span class="number">1</span>));</span><br><span class="line">Map&lt;Object, Object&gt; regionTrainStationAllMap = stringRedisTemplate.opsForHash().entries(buildRegionTrainStationHashKey);</span><br><span class="line"><span class="keyword">if</span> (MapUtil.isEmpty(regionTrainStationAllMap)) &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(LOCK_REGION_TRAIN_STATION);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        regionTrainStationAllMap = stringRedisTemplate.opsForHash().entries(buildRegionTrainStationHashKey);</span><br><span class="line">        <span class="keyword">if</span> (MapUtil.isEmpty(regionTrainStationAllMap)) &#123;</span><br><span class="line">            LambdaQueryWrapper&lt;TrainStationRelationDO&gt; queryWrapper = Wrappers.lambdaQuery(TrainStationRelationDO.class)</span><br><span class="line">                    .eq(TrainStationRelationDO::getStartRegion, stationDetails.get(<span class="number">0</span>))</span><br><span class="line">                    .eq(TrainStationRelationDO::getEndRegion, stationDetails.get(<span class="number">1</span>));</span><br><span class="line">            List&lt;TrainStationRelationDO&gt; trainStationRelationList = trainStationRelationMapper.selectList(queryWrapper);</span><br><span class="line">            <span class="keyword">for</span> (TrainStationRelationDO each : trainStationRelationList) &#123;</span><br><span class="line">                <span class="type">TrainDO</span> <span class="variable">trainDO</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">                        TRAIN_INFO + each.getTrainId(),</span><br><span class="line">                        TrainDO.class,</span><br><span class="line">                        () -&gt; trainMapper.selectById(each.getTrainId()),</span><br><span class="line">                        ADVANCE_TICKET_DAY,</span><br><span class="line">                        TimeUnit.DAYS);</span><br><span class="line">                <span class="type">TicketListDTO</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketListDTO</span>();</span><br><span class="line">                result.setTrainId(String.valueOf(trainDO.getId()));</span><br><span class="line">                result.setTrainNumber(trainDO.getTrainNumber());</span><br><span class="line">                result.setDepartureTime(convertDateToLocalTime(each.getDepartureTime(), <span class="string">&quot;HH:mm&quot;</span>));</span><br><span class="line">                result.setArrivalTime(convertDateToLocalTime(each.getArrivalTime(), <span class="string">&quot;HH:mm&quot;</span>));</span><br><span class="line">                result.setDuration(DateUtil.calculateHourDifference(each.getDepartureTime(), each.getArrivalTime()));</span><br><span class="line">                result.setDeparture(each.getDeparture());</span><br><span class="line">                result.setArrival(each.getArrival());</span><br><span class="line">                result.setDepartureFlag(each.getDepartureFlag());</span><br><span class="line">                result.setArrivalFlag(each.getArrivalFlag());</span><br><span class="line">                result.setTrainType(trainDO.getTrainType());</span><br><span class="line">                result.setTrainBrand(trainDO.getTrainBrand());</span><br><span class="line">                <span class="keyword">if</span> (StrUtil.isNotBlank(trainDO.getTrainTag())) &#123;</span><br><span class="line">                    result.setTrainTags(StrUtil.split(trainDO.getTrainTag(), <span class="string">&quot;,&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="variable">betweenDay</span> <span class="operator">=</span> cn.hutool.core.date.DateUtil.betweenDay(each.getDepartureTime(), each.getArrivalTime(), <span class="literal">false</span>);</span><br><span class="line">                result.setDaysArrived((<span class="type">int</span>) betweenDay);</span><br><span class="line">                result.setSaleStatus(<span class="keyword">new</span> <span class="title class_">Date</span>().after(trainDO.getSaleTime()) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">                result.setSaleTime(convertDateToLocalTime(trainDO.getSaleTime(), <span class="string">&quot;MM-dd HH:mm&quot;</span>));</span><br><span class="line">                seatResults.add(result);</span><br><span class="line">                regionTrainStationAllMap.put(CacheUtil.buildKey(String.valueOf(each.getTrainId()), each.getDeparture(), each.getArrival()), JSON.toJSONString(result));</span><br><span class="line">            &#125;</span><br><span class="line">            stringRedisTemplate.opsForHash().putAll(buildRegionTrainStationHashKey, regionTrainStationAllMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再获取到 <code>车票余额、车座次相对应的价格</code> 并进行缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">seatResults = CollUtil.isEmpty(seatResults)</span><br><span class="line">                ? regionTrainStationAllMap.values().stream().map(each -&gt; JSON.parseObject(each.toString(), TicketListDTO.class)).toList()</span><br><span class="line">                : seatResults;</span><br><span class="line">        seatResults = seatResults.stream().sorted(<span class="keyword">new</span> <span class="title class_">TimeStringComparator</span>()).toList();</span><br><span class="line">        <span class="keyword">for</span> (TicketListDTO each : seatResults) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">trainStationPriceStr</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">                    String.format(TRAIN_STATION_PRICE, each.getTrainId(), each.getDeparture(), each.getArrival()),</span><br><span class="line">                    String.class,</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        LambdaQueryWrapper&lt;TrainStationPriceDO&gt; trainStationPriceQueryWrapper = Wrappers.lambdaQuery(TrainStationPriceDO.class)</span><br><span class="line">                                .eq(TrainStationPriceDO::getDeparture, each.getDeparture())</span><br><span class="line">                                .eq(TrainStationPriceDO::getArrival, each.getArrival())</span><br><span class="line">                                .eq(TrainStationPriceDO::getTrainId, each.getTrainId());</span><br><span class="line">                        <span class="keyword">return</span> JSON.toJSONString(trainStationPriceMapper.selectList(trainStationPriceQueryWrapper));</span><br><span class="line">                    &#125;,</span><br><span class="line">                    ADVANCE_TICKET_DAY,</span><br><span class="line">                    TimeUnit.DAYS</span><br><span class="line">            );</span><br><span class="line">            List&lt;TrainStationPriceDO&gt; trainStationPriceDOList = JSON.parseArray(trainStationPriceStr, TrainStationPriceDO.class);</span><br><span class="line">            List&lt;SeatClassDTO&gt; seatClassList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            trainStationPriceDOList.forEach(item -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">seatType</span> <span class="operator">=</span> String.valueOf(item.getSeatType());</span><br><span class="line">                <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;_&quot;</span>, each.getTrainId(), item.getDeparture(), item.getArrival());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">quantityObj</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().get(TRAIN_STATION_REMAINING_TICKET + keySuffix, seatType);</span><br><span class="line">                <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> Optional.ofNullable(quantityObj)</span><br><span class="line">                        .map(Object::toString)</span><br><span class="line">                        .map(Integer::parseInt)</span><br><span class="line">                        .orElseGet(() -&gt; &#123;</span><br><span class="line">                            Map&lt;String, String&gt; seatMarginMap = seatMarginCacheLoader.load(String.valueOf(each.getTrainId()), seatType, item.getDeparture(), item.getArrival());</span><br><span class="line">                            <span class="keyword">return</span> Optional.ofNullable(seatMarginMap.get(String.valueOf(item.getSeatType()))).map(Integer::parseInt).orElse(<span class="number">0</span>);</span><br><span class="line">                        &#125;);</span><br><span class="line">                seatClassList.add(<span class="keyword">new</span> <span class="title class_">SeatClassDTO</span>(item.getSeatType(), quantity, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(item.getPrice()).divide(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;100&quot;</span>), <span class="number">1</span>, RoundingMode.HALF_UP), <span class="literal">false</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">            each.setSeatClassList(seatClassList);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>到这里，基本上就结束了，中间三个代码段都是 对车票部分进行查询、缓存，还有一部分不好的地方，我找个时间补上。</p><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>这个项目查询车票流程基本这样，对于 <code>网关</code> 实现方式多，本项目是通过继承 <code>AbstractGatewayFilterFactory</code> ，主要重写 <code>apply</code> 方法实现。</p><p>有很多代码写得很美，<br>像一开始的责任链模式进行参数校验，责任链实现在包<code>frameworks.designpattern</code>(前几太看的时候我还记得是如何加载的，现在我已经忘了T_T)<br>然后就是用 <code>@FunctionalInterface</code>只写一个接口，文中用了很多，举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;StationQueryRespDTO&gt; <span class="title function_">listAllStation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> distributedCache.safeGet(</span><br><span class="line">            STATION_ALL,</span><br><span class="line">            List.class,</span><br><span class="line">            () -&gt; BeanUtil.convert(stationMapper.selectList(Wrappers.emptyWrapper()), StationQueryRespDTO.class),</span><br><span class="line">            ADVANCE_TICKET_DAY,</span><br><span class="line">            TimeUnit.DAYS</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>() -&gt; BeanUtil.convert(stationMapper.selectList(Wrappers.emptyWrapper()), StationQueryRespDTO.class)</code> 是实现 <code>CacheLoader</code> 的 <code>load()</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CacheLoader</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">load</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>这有什么好处呢？</code></p><p>我们写这样一个接口，<code>通过函数式编程方式，直接写上实现。不用再依次写具体实现，然后再调用，极大增强复用性，查这个写一个实现，查那个写一个实现</code></p><p>雅，太雅了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 12306 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.17</title>
      <link href="/posts/10-17/"/>
      <url>/posts/10-17/</url>
      
        <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>先给看看工位。</p><img src="/img/10-17/gw.jpg" alt="自己的工位"/><p>经理给我配的旧的苹果，俺不会用，就给我配了Windows。果然 <code>野猪吃不了细康</code></p><p>工作一个多月了,按考勤算钱，第一个月又遇到国庆、中秋，那几天真希望自己天天上班，狠狠赚。</p><p>这个公司很小， <code>真正在干事儿的就6个人!其中还包括经理、包括我在内的三个实习生</code> 。但人家是19年就建立的。还有一位4年老员工。</p><p>第一天进公司，就收到通知被重庆德勤给录取了。但是我才租上房啊，还大老远从学校跑来，又坐车回去。<br><img src="/img/10-17/dqlq.jpg" alt="整洋文"><br>这俩工资是一样多的，但我不想多花父母的钱就没回重庆。爸给我说让我回去，我骗他说被撤回了。(小声bb一下，我也受到一些网络影响，说德勤分配完全看运气，有些好有些差。有大佬，有导师但完全看 <code>运气</code> )</p><p>也想过回重庆现在是不是已经有更好发展，是个高楼白领了，哈哈哈。</p><p>无所谓，在哪都是学。</p><p>我这儿的经理人挺好，说话都很和气，对实习生也不错，是个 <code>技术佬</code> 。我对这样的人啊，真是像个小孩一样。这几天犯了一个错，在人面前像个沙贝一样扭扭捏捏的，真想回去抽自己一个大嘴巴子。</p><p>前几天安排写一个脚本，从数据库上把数据扒出来，因为阿里那个数据库好像是只能上传，不能保存。<br>那是我第一个活儿，写得老快了， <code>感觉自己改的代码优雅丝滑</code>（现在想想就是傻呗迷之自信） ，越看越觉得自己屌，后面发现一些错误，又修修补补，又加上日志查看进度、配置文件。又这又那，感觉代码优雅得一批。<br>结果前天同事提醒我这个脚本有个BUG，某些情况会少数据。</p><p>哈哈哈， <code>结果我就急了</code> 。也没敢问经理，也没敢告诉他，因为我觉得这太easy了， <code>索性就把查到的2/3数据全删了</code> ，重头开始。(狂删自己巴掌，下次删片，别删数据)</p><p>哈哈哈，后端开发成全栈开发，让我页面美化，这真比不过同事，就让我很焦虑。</p><p>今天早上5点才睡着，8点多又拖着疲惫身躯上班了。</p><p>今天索性一问，说没事儿，让我接着查。<br>我都删了，拿啥查，又没给他说已经把数据删了。<br>结果他来问还差多少，我就实话实说了(为啥不早给他说)</p><p>生活，就是生下来，然后活着。</p><p>我现在就想挣钱，挣大把的钱。</p><p>听一首 DAY 1 好好睡一觉吧。接下来就好好工作，好好生活。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本站</title>
      <link href="/posts/%E6%9C%AC%E7%AB%99/"/>
      <url>/posts/%E6%9C%AC%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="关于本站"><a href="#关于本站" class="headerlink" title="关于本站"></a>关于本站</h1><p>其实很早之前一直想创建一个属于自己的博客。</p><p>从自己学习Java后端开始，就尝试过自己自研一个，后面发现自己写一个博客的工作量非常大，自己的前端学得也只是逻辑方面，对于美化方面做得很烂。</p><p>很早就了解到了有现成博客模板，折腾一下发现大量配置又给搁置了。</p><p>这一次终于下定决心了，一定要弄一个出来。</p><p>2024年10月13日</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
