<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql</title>
      <link href="/posts/mysql/mysql/"/>
      <url>/posts/mysql/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>摘要，记录一些自己认为重要需要学习的。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。<br>INT(11) 中的<code>数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的</code>。  </p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><code>FLOAT</code> 和 <code>DOUBLE</code> 浮点类型，<code>DECIMAL</code> 为高精度小数类型。  </p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>主要有 <code>CHAR</code> 和 <code>VARCHAR</code> 两种类型，一种是定长的，一种是变长的。<br><code>VARCHAR</code> 会保留字符串末尾的空格， <code>char</code> 会删除  </p><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p><code>DATETIME</code> 和 <code>TIMESTAMP</code><br><code>DATETIME</code> 能够保存1001年到9999年时间，精度为秒，使用8字节存储。 <code>与时区无关</code><br><code>TIMESTAMP</code> 和UNIX时间戳相同，保存从1970年1月1日午夜以来的秒数，使用4个字节，只能表示从1970-2038年。 <code>与时区有关</code> 。  </p><h3 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h3><ul><li><code>更小</code> 的数据类型通常更快，<code>因为它占用更少磁盘、内存和CPU缓存，并且处理周期少</code>  </li><li><code>简单就好</code> 例如：整形比字符串操作代价更小  </li><li><code>避免使用NULL</code> 如果查询列包含NULL，对SQL来说优化更难，因为 <code>NULL使得索引、统计和值比较变得复杂， 尽量使索引包含的字段设置成 NOT NULL</code></li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>MySQL默认的 <code>事务型引擎</code> ，支持真正的 <code>在线热备份</code> 。  </p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。 <code>但在表有读取操作的同时，也可以往表中插入新的记录</code> ，这被称为并发插入(CONCURRENT INSERT)。  </p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li>事务：Innodb是事务型，可以使用 <code>Commit</code> 和 <code>Rollback</code></li><li>并发：MyISAM 只支持 表级锁 ， InnoDB支持 <code>行级锁(即锁一条数据)</code> 。</li><li>外键：InnoDB支持</li><li>备份： InnoDB支持在线热备份</li></ul><h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><p><code>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。</code> InnoDB存储引擎中默认每个页的大小为 <code>16KB</code> ，可通过参数 <code>innodb_page_size</code> 将页的大小设置为4K、8K、16K</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。<br>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。  </p><p><code>B Tree 和 B + Tree的最大区别</code>  </p><ul><li>B Tree每个节点都带有key和data，而 B + Tree <code>非叶子节点只有key</code>，所以<code>相同量的数据B + Tree更加矮胖，减少了检索次数，更加高效</code>。</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。 <code>插入删除操作记录会破坏平衡树的平衡性</code> ，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。<code>尽量减少插入或使键有序，也减少删除</code>  </p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li><code>对索引使用函数</code>  </li><li><code>OR 条件左边是索引右边不是索引</code>  </li><li><code>左模糊查询或者左右模糊查询</code>  </li><li><code>未满足最左前匹配</code>  </li><li><code>查询条件左边为字符串出现了隐式转换</code></li></ul><h3 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h3><ul><li>通过 <code>explain</code> 进行语法分析，分析key是否用了索引，rows扫描的行数等</li><li><code>尽量不要select *，返回必要的列</code>， <code>尽量用LIMIT限制返回的行</code>  </li><li><code>缓存重复查询的数据，可以避免重复查询数据库，还能提高查询效率</code></li><li><code>减少扫描行数，尽量使用覆盖索引</code>  </li><li>对大SQL进行分解,<code>因为一个大DML SQL会锁住很多数据，耗尽资源，阻塞很多小而重要的SQL</code>， 分解SQL<code>易于让缓存利用更加高效，在应用层进行连接，可以更容易对数据库进行拆分，从而更好做到高性能和可伸缩</code></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>读未提交(一个事务能<code>读到另外一个事务未提交的数据</code>)</li><li>读已提交(一个事务提交的数据能被其他事务读取)</li><li>可重复读(一个事务读取的数据和事务 <code>开启时保持一致</code> )  <code>InnoDB默认隔离级别</code>   </li><li>串行化(对记录进行 <code>加锁</code> ，如果多个事务发生 <code>读写冲突</code> ， <code>后访问的事务必须等前一个事务执行完成</code> 才能继续执行)</li></ul><h3 id="隔离级别的实现方式"><a href="#隔离级别的实现方式" class="headerlink" title="隔离级别的实现方式"></a>隔离级别的实现方式</h3><ul><li>对于[读未提交] 直接读取最新数据即可  </li><li>对于[串行化] ，通过加读写锁来避免并行访问</li><li>对于 [读已提交] 和 [可重复读] ，通过<code>Read View</code> 实现， <code>区别在于创建Read View的时机不同，Read View类似于数据快照，[读已提交]在[每个语句执行前]生成，而[可重复读]则是在[启动事务时]生成一个 Read View</code></li></ul><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h3><p>InnoDB引擎在[可重复读]隔离级别下，<code>很大程度上避免了幻读</code> </p><ul><li>针对 <code>快照读</code>(普通select语句)，<code>通过 MVCC 方式解决幻读</code><br>· 快照读是 <code>不加锁读，基于MVCC实现的，当隔离级别是可串行化时，会自动退化成当前读</code></li><li>针对<code>当前读</code>(select.. for update) <code>通过next-key lock(记录锁+间隙锁)方式解决幻读</code><br>· 当前读是指读取最新数据，读取保证其他并发事务不能修改当前记录， <code>会对读取数据进行加锁</code></li></ul><h3 id="Read-View在MVCC中的工作"><a href="#Read-View在MVCC中的工作" class="headerlink" title="Read View在MVCC中的工作"></a>Read View在MVCC中的工作</h3><p>Read View中的四个字段可以把事务分为 <code>已经提交的事务</code>、 <code>当前事务id</code> 、<code>创建Read View时，当前活跃且未提交事务的id范围</code>以及 <code>还未开始的事务</code><br>聚簇索引中包含两个隐藏字段 <code>对该行更改的事务trx_id</code> 和 <code>指向旧版本的指针，旧版本的记录写入到 undo 日志中</code>  </p><p>一个事务对记录进行访问时，会将 <code>trx_id在Read View中进行比较</code>  </p><ul><li>如果 <code>trx_id小于最小活跃事务id</code> ,则表示该版本是在创建此Read View之前已经提交了的版本，因此可见  </li><li>如果 <code>trx_id大于等于还未开始事务的id</code> ,则表示该记录版本是  <code>在创建该Read View后启动事务更改的，所以该版本不可见</code>  </li><li>如果 <code>trx_id在上述情况之间，则需判断是否在活跃且未提交事务id范围中</code><br>· 如果trx_id<code>在已启动且未提交事务范围中，则表明生成该版本的事务还在活跃，所以该版本不可见</code><br>· 如果trx_id<code>不在已启动且未提交事务范围中，则表明生成该版本的事务已经提交，所以该版本可见</code>  </li><li>虽然MVCC只是很大程度避免了幻读， <code>但还是存在幻读</code> ，比如 <code>事务A更新了一条事务B插入的记录，那么事务A前后两次查询的记录就不一样了</code></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>MySQL加锁可以分为 <code>全局锁</code> 、 <code>表锁</code> 、 <code>行锁</code> 三类</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul><li>元数据锁<br>· 对一张表进行CRUD时，会自动加 <code>MDL 读锁</code><br>· 对一张表进行结构变化时，会自动加 <code>MDL 写锁</code></li></ul><p>MDL锁是为了保证当前用户进行操作时，防止其他线程对这个表结构进行更改。<code>写锁优先级高于读锁</code></p><ul><li><p>意向锁</p></li><li><p>AUTO-INC锁<br>表主键为自增时，<code>在新增数据时，会持有该锁，在新增完成后就会释放。</code></p></li></ul><p>Innodb提供了一种轻量锁，<code>给自增字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</code></p><h3 id="行级锁种类"><a href="#行级锁种类" class="headerlink" title="行级锁种类"></a>行级锁种类</h3><ul><li><p>记录锁(锁住一条记录)<br>· 当事务当前读查询获取到该记录的记录锁， <code>其他事务对该记录的更新和删除会发生阻塞</code>，如果其他事务进行插入不会阻塞，因为会报错主键重复</p></li><li><p>间隙锁(锁住一个范围，<code>左开有开区间</code>)<br>·  <code>只存在于可重复读级别，目的是为了解决可重复读的幻读</code><br>· <code>两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥，因为间隙锁目的是为了防止插入幻影记录</code> </p></li><li><p>next-key lock锁(记录锁和间隙锁的组合， <code>左开右闭区间</code>)</p></li></ul><h3 id="针对当前读加锁"><a href="#针对当前读加锁" class="headerlink" title="针对当前读加锁"></a>针对当前读加锁</h3><h3 id="MySQL如何加锁"><a href="#MySQL如何加锁" class="headerlink" title="MySQL如何加锁"></a>MySQL如何加锁</h3><p>加锁的对象是 <code>索引</code>，加锁的基本单位是<code>next-key lock，左开右闭区间</code>  </p><p>在某些情况下，如果使用记录锁或间隙锁就足以防止幻读现象的发生，那么next-key lock就会退化成记录锁或间隙锁。  </p><ul><li><p>当我们用 <code>主键索引进行等值查询</code> ，<code>如果记录存在，则退化成 [记录锁] ， 如果记录不存在，则退化成 [间隙锁] </code>  </p></li><li><p>当我们用<code>主键索引进行范围查询时</code>，会对每一个扫描到的索引加next-lock锁<br>· 针对<code>大于等于</code>，因为存在等值，所以对扫描到的记录<code>退化成记录锁</code><br>· 针对<code>小于等于或者小于</code>，  <code>取决于条件值的记录是否存在</code><br>· 如果<code>记录在表中不存在</code> ， <code>扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化成间隙锁</code>，其他扫描到的记录加next-key锁<br>· 当查询 <code>记录在表中存在</code> ，如果是 <code>小于条件</code> ， <code>扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化成间隙锁</code> ，其他为next-lock锁   </p></li><li><p>当我们用<code>非主键索引进行等值查询时</code> ， <code>因为存在两个索引，一个是主键索引，一个是二级索引，所以在加锁时，同时会对这两个索引加锁，但对主键索引加锁时，只有满足查询条件的记录才会对它们的主键索引加锁</code><br>· 当 <code>查询的记录存在</code> 时，<code>会进行二级索引扫描，直到扫描到第一个不符合条件的记录就停止，然后对扫描到的二级索引添加 next-lock锁 ，而对于第一个不符合条件的索引退化成间隙锁，同时在符合条件的记录的主键索引添加记录锁</code><br>· 当 <code>查询记录不存在</code> 时，扫描到第一个不符合条件的二级索引记录，该二级索引的next-key锁会退化成间隙锁。因为不满足查询条件，所以<code>不会对主键索引加锁</code>  </p></li><li><p>当我们用<code>非主键索引进行范围查询时，索引的next-lock 锁不会退化！！！</code></p></li></ul><h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><ol><li><p>连接器<br>· 首先经过连接器进行连接，先经过 <code>TCP</code> 三次握手建立连接后， <code>验证账号密码</code> ,通过则建立长连接</p></li><li><p>查询缓存(8.0将这一部分删掉)<br>· 如果有这一步则进行查询看是否执行过这一条语句，缓存以key-value形式存储，key为查询语句  </p></li><li><p>解析器-解析SQL<br>· 进行 <code>词法分析</code>获取关键字 ， <code>语法分析</code>  判断SQL满足规则，建立SQL语法树。</p></li><li><p>执行SQL<br>· <code>预处理器</code> 检查字段是否存在，将*扩展为所有列<br>· <code>优化器</code> 负责将语句的执行方案确定下来，基于内部的选择来决定走哪个索引等<br>· <code>执行器</code> 与存储引擎进行交互</p></li></ol><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="undo-log-回滚日志-实现事务中的原子性，用于事务-回滚-和-MVCC"><a href="#undo-log-回滚日志-实现事务中的原子性，用于事务-回滚-和-MVCC" class="headerlink" title="undo log(回滚日志) 实现事务中的原子性，用于事务 回滚 和 MVCC"></a>undo log(回滚日志) 实现事务中的原子性，用于事务 回滚 和 MVCC</h3><ul><li>在 <code>插入</code> 一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录 <code>删掉</code> 就好了；</li><li>在 <code>删除</code> 一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录 <code>插入</code> 到表中就好了；</li><li>在 <code>更新</code> 一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列 <code>更新为旧值</code> 就好了。</li></ul><h3 id="redo-log-重做日志-实现事务中的持久化，用于掉电等故障恢复"><a href="#redo-log-重做日志-实现事务中的持久化，用于掉电等故障恢复" class="headerlink" title="redo log(重做日志) 实现事务中的持久化，用于掉电等故障恢复"></a>redo log(重做日志) 实现事务中的持久化，用于掉电等故障恢复</h3><p>Buffer Pool会把存储的数据划分为若干个页，默认 <code>16KB</code> ，叫做 <code>缓存页</code></p><p>Buffer Pool 是为了提高读写效率，但它是基于内存，内存不可靠。</p><p>为了防止断电等导致数据丢失，当记录一条数据时， Innodb 会先更新内存(同时标记为 <code>脏页</code> )，会在合适的时机，由后台线程将缓存在 Buffer Pool 中的数据刷到磁盘上，这就是 <code>WAL 技术</code></p><p>redo log 和 undo log的区别</p><ul><li>redo log 记录了此次事务 <code>完成后</code> 的数据状态，记录的是更新 <code>之后</code> 的新值</li><li>undo log 记录此次事务 <code>开始时</code> 的数据状态，记录的是 <code>之前 </code>的旧值<br>事务提交之前发生崩溃，通过undo log 进行回滚数据，事务提交后发生崩溃，通过 redo log 进行恢复<br>redo log 是追加方式，所以是[顺序写]入磁盘；而写入数据是[随机写]。这就好比一个记事本按顺序一直往下写和写一个字要找对应的页。<br>redo log 实现了 <code>事务的持久性，让 MySQL 有了崩溃恢复的能力</code>， <code>将写操作从[随机写]转变为[顺序写]，提升写入磁盘性能</code>。</li></ul><p>产生的 redo log 也 <code>不是直接写入磁盘</code> ，因为这样产生大量 I&#x2F;O 效率低下</p><p>redo log 有自己的缓存- <code>redo log buffer</code><br>写入时机：</p><ul><li>MySQL 正常关机</li><li>当 redo log buffer 写入量超过 <code>1/2</code> 时，将 redo log buffer 写入磁盘</li><li>Innodb 后台线程每隔一秒，持久化一次</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</li></ul><p>redo log 实际是由两个 log 文件(一个大小默认为 1GB )组成，两个文件循环写， <code>当redo log写的 Buffer Pool 脏数据超过redo log大小，即 redo log 写满后</code> ，就会阻塞 MySQL ，此时 <code>会停下来将 Buffer Pool 中的脏数据刷新到磁盘中，然后标记 redo log 哪些可以删除，接着对旧的 redo log 进行擦除，腾出空间，然后 MySQL 恢复正常</code></p><h3 id="bin-log-归档日志-主要用于数据备份和主从复制"><a href="#bin-log-归档日志-主要用于数据备份和主从复制" class="headerlink" title="bin log(归档日志) 主要用于数据备份和主从复制"></a>bin log(归档日志) 主要用于数据备份和主从复制</h3><p>MySQL 执行完一条更新操作后，还会生成一条 binlog，等事务提交后，会将该事务产生的 binlog统一写入 binlog 文件。</p><p>binlog 主要记录所有数据库表结构变更和表数据修改的日志， <code>不会记录查询类的操作</code></p><h4 id="redo-log-和-binlog区别"><a href="#redo-log-和-binlog区别" class="headerlink" title="redo log 和 binlog区别"></a>redo log 和 binlog区别</h4><ol><li>适用范围不同<ul><li>binlog是 MySQL 的 Server 层实现的，任何存储引擎都可以使用</li><li>redo log 是 Innodb 存储引擎实现的日志</li></ul></li><li>文件格式不一样<ul><li>binlog 有三种格式类型：STATEMENT、 ROW、MIXED<ul><li>STATEMENT：<code>记录的是SQL语句</code> ，相当于逻辑日志；但有 <code>动态函数问题</code> ，比如用了 uuid 或 now 函数，在主库上执行的结果并不是在从库上执行的结果，这种随时在变的函数会导致数据复制不一致。</li><li>ROW：<code>记录的是数据变更</code> ，每行数据变化的结果都会记录，使 binlog 文件过大</li><li>MIXED: <code>STATEMENT + ROW</code> 模式，会根据不同情况使用</li></ul></li><li>redo log是物理日志，记录某个数据页的修改，比如对XX表空间中的YY数据页ZZ偏移量的地方AAA更新</li></ul></li><li>写入方式<ul><li>binlog 是追加写，写满之后新建</li><li>redo log 是循环写，日志空间固定</li></ul></li><li>用途不一样<ul><li>binlog 是数据备份、主从复制</li><li>redo log 掉电等故障恢复</li></ul></li></ol><h4 id="主从复制模型"><a href="#主从复制模型" class="headerlink" title="主从复制模型"></a>主从复制模型</h4><ul><li>同步复制: MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回结果。</li><li>异步复制(默认): MySQL 主库提交事务的线程不等待从库复制成功，直接返回。</li><li>半同步复制：MySQL 5.7 版本之后新增的方式，事务不用等待所有从库复制成功响应， <code>只用返回一部分复制成功响应即可</code>。半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。</li></ul><p>当一个事务提交后，其 <code>产生的 binlog 先写入 binlog cache </code> ，每个线程都有一个。</p><p>binlog 刷盘是根据参数 <code>sync_binlog</code> 来控制的</p><ul><li><code>sync_binlog=0</code>: 每次提交事务只 write，不fsync，后续由系统决定</li><li><code>sync_binlog=1</code>: 每次提交事务都 write 和 fsync</li><li><code>sync_binlog=N</code>: N 次 write 后，执行 fsync</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12306(一)</title>
      <link href="/posts/12306/12306(%E4%B8%80)/"/>
      <url>/posts/12306/12306(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>本项目为<a href="https://github.com/Wangbangc/12306">开源项目</a></p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>先了解相关包，对项目有个整体的了解。<br><img src="/img/12306/package.png" alt="包相关说明" /></p><p>配置相关看 <a href="https://nageoffer.com/12306/environment-configuration/">官方环境搭建</a> 就行了</p><h1 id="站点查询相关"><a href="#站点查询相关" class="headerlink" title="站点查询相关"></a>站点查询相关</h1><p>因为 <code>查询大多都类似</code> ，比较复杂的就是首页进行车票查询，所以再这里只写一个</p><p>接口 <code>/api/ticket-service/ticket/query</code> ，查询车票(默认访问查询 <code>北京到杭州的车票</code> )访问首页即可触发</p><p>大致流程: 请求首先会在网关中被拦截，然后通过黑白名单进行过滤，请求再到相应服务端进行处理，对于上述车票的查询，<code>网关路由到服务端后首先查询缓存，查询不到就查询数据库，并将相关数据存储在缓存中</code>。</p><p>具体流程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端接口</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api/ticket-service/ticket/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;TicketPageQueryRespDTO&gt; pageListTicketQuery</span><br><span class="line"><span class="comment">// 参数为 两站台缩写</span></span><br><span class="line">(TicketPageQueryReqDTO requestParam) &#123;</span><br><span class="line">    <span class="keyword">return</span> Results.success(</span><br><span class="line">        ticketService.pageListTicketQueryV1(requestParam));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到实现层后，第一行代码就是利用 <code>责任链模式</code>，首先 <code>对参数进行校验</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 责任链模式 验证城市名称是否存在、不存在加载缓存以及出发日期不能小于当前日期等等</span></span><br><span class="line">ticketPageQueryAbstractChainContext.handler</span><br><span class="line"><span class="comment">// 第一个参数是标记，用于区分不同的责任链</span></span><br><span class="line"><span class="comment">// 第二个是要进行校验的参数</span></span><br><span class="line">(TicketChainMarkEnum.TRAIN_QUERY_FILTER.name(), requestParam);</span><br></pre></td></tr></table></figure><p>再进入到 <code>ticketPageQueryAbstractChainContext</code> 时，首先我们要看一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个单接口， <code>文中用了大量的 @FunctionalInterface 来标识接口，我能想到的目的就是规范开发， 只定义一个接口增加灵活性，方便扩展 ? </code></p><p>接下来再进入 <code>ticketPageQueryAbstractChainContext</code> 查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AbstractChainContext</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;AbstractChainHandler&gt;&gt; abstractChainHandlerContainer </span><br><span class="line">    = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 责任链组件执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mark         责任链组件标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestParam 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(String mark, T requestParam)</span> &#123;</span><br><span class="line">        List&lt;AbstractChainHandler&gt; abstractChainHandlers </span><br><span class="line">        = abstractChainHandlerContainer.get(mark);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(abstractChainHandlers)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String</span><br><span class="line">            .format(<span class="string">&quot;[%s] Chain of Responsibility ID is undefined.&quot;</span>, mark));</span><br><span class="line">        &#125;</span><br><span class="line">        abstractChainHandlers.</span><br><span class="line">        forEach(each -&gt; each.handler(requestParam));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在初始化时就进行装载， 我给忘了在哪里加载来着。chao TODO</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;String, AbstractChainHandler&gt; chainFilterMap = ApplicationContextHolder</span><br><span class="line">                .getBeansOfType(AbstractChainHandler.class);</span><br><span class="line">        chainFilterMap.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">            List&lt;AbstractChainHandler&gt; abstractChainHandlers = </span><br><span class="line">            abstractChainHandlerContainer.get(bean.mark());</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(abstractChainHandlers)) &#123;</span><br><span class="line">                abstractChainHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            abstractChainHandlers.add(bean);</span><br><span class="line">            List&lt;AbstractChainHandler&gt; actualAbstractChainHandlers = </span><br><span class="line">            abstractChainHandlers.stream()</span><br><span class="line">                    .sorted(Comparator.comparing(Ordered::getOrder))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">            abstractChainHandlerContainer.put(bean.mark(), actualAbstractChainHandlers);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述最重要的是 <code>abstractChainHandlers.forEach(each -&gt; each.handler(requestParam));</code><br>将参数依次传到责任链进行相关校验</p><p><code>之后基本上都是查询数据库写入缓存的操作，我只写逻辑，没怎么给注释</code> </p><p><code>感觉代码很美</code>，可以多看看写法，很帅</p><p>校验完成后尝试从 Redis 缓存中进行获取两地信息，如果获取不到就加锁用 <code>双重校验锁(锁前查询一次，锁后再查询一次)</code> 进行 数据库获取 <code>所有站台缩写与城市之间的映射关系</code> 查询并插入 缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; stationDetails = stringRedisTemplate.opsForHash()</span><br><span class="line">        .multiGet(REGION_TRAIN_STATION_MAPPING,</span><br><span class="line">                Lists.newArrayList(requestParam.getFromStation(), requestParam.getToStation()));</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stationDetails.stream().filter(Objects::isNull).count();</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(LOCK_REGION_TRAIN_STATION_MAPPING);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stationDetails = stringRedisTemplate.opsForHash()</span><br><span class="line">                .multiGet(REGION_TRAIN_STATION_MAPPING, Lists.newArrayList(requestParam.getFromStation(), requestParam.getToStation()));</span><br><span class="line">        count = stationDetails.stream().filter(Objects::isNull).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;StationDO&gt; stationDOList = stationMapper.selectList(Wrappers.emptyWrapper());</span><br><span class="line">            Map&lt;String, String&gt; regionTrainStationMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            stationDOList.forEach(each -&gt; regionTrainStationMap.put(each.getCode(), each.getRegionName()));</span><br><span class="line">            stringRedisTemplate.opsForHash().putAll(REGION_TRAIN_STATION_MAPPING, regionTrainStationMap);</span><br><span class="line">            stationDetails = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            stationDetails.add(regionTrainStationMap.get(requestParam.getFromStation()));</span><br><span class="line">            stationDetails.add(regionTrainStationMap.get(requestParam.getToStation()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到数据后，再通过同样的方式，获取到 <code>所有北京到杭州站点的车票</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TicketListDTO&gt; seatResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">buildRegionTrainStationHashKey</span> <span class="operator">=</span> String.format(REGION_TRAIN_STATION, stationDetails.get(<span class="number">0</span>), stationDetails.get(<span class="number">1</span>));</span><br><span class="line">Map&lt;Object, Object&gt; regionTrainStationAllMap = stringRedisTemplate.opsForHash().entries(buildRegionTrainStationHashKey);</span><br><span class="line"><span class="keyword">if</span> (MapUtil.isEmpty(regionTrainStationAllMap)) &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(LOCK_REGION_TRAIN_STATION);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        regionTrainStationAllMap = stringRedisTemplate.opsForHash().entries(buildRegionTrainStationHashKey);</span><br><span class="line">        <span class="keyword">if</span> (MapUtil.isEmpty(regionTrainStationAllMap)) &#123;</span><br><span class="line">            LambdaQueryWrapper&lt;TrainStationRelationDO&gt; queryWrapper = Wrappers.lambdaQuery(TrainStationRelationDO.class)</span><br><span class="line">                    .eq(TrainStationRelationDO::getStartRegion, stationDetails.get(<span class="number">0</span>))</span><br><span class="line">                    .eq(TrainStationRelationDO::getEndRegion, stationDetails.get(<span class="number">1</span>));</span><br><span class="line">            List&lt;TrainStationRelationDO&gt; trainStationRelationList = trainStationRelationMapper.selectList(queryWrapper);</span><br><span class="line">            <span class="keyword">for</span> (TrainStationRelationDO each : trainStationRelationList) &#123;</span><br><span class="line">                <span class="type">TrainDO</span> <span class="variable">trainDO</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">                        TRAIN_INFO + each.getTrainId(),</span><br><span class="line">                        TrainDO.class,</span><br><span class="line">                        () -&gt; trainMapper.selectById(each.getTrainId()),</span><br><span class="line">                        ADVANCE_TICKET_DAY,</span><br><span class="line">                        TimeUnit.DAYS);</span><br><span class="line">                <span class="type">TicketListDTO</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketListDTO</span>();</span><br><span class="line">                result.setTrainId(String.valueOf(trainDO.getId()));</span><br><span class="line">                result.setTrainNumber(trainDO.getTrainNumber());</span><br><span class="line">                result.setDepartureTime(convertDateToLocalTime(each.getDepartureTime(), <span class="string">&quot;HH:mm&quot;</span>));</span><br><span class="line">                result.setArrivalTime(convertDateToLocalTime(each.getArrivalTime(), <span class="string">&quot;HH:mm&quot;</span>));</span><br><span class="line">                result.setDuration(DateUtil.calculateHourDifference(each.getDepartureTime(), each.getArrivalTime()));</span><br><span class="line">                result.setDeparture(each.getDeparture());</span><br><span class="line">                result.setArrival(each.getArrival());</span><br><span class="line">                result.setDepartureFlag(each.getDepartureFlag());</span><br><span class="line">                result.setArrivalFlag(each.getArrivalFlag());</span><br><span class="line">                result.setTrainType(trainDO.getTrainType());</span><br><span class="line">                result.setTrainBrand(trainDO.getTrainBrand());</span><br><span class="line">                <span class="keyword">if</span> (StrUtil.isNotBlank(trainDO.getTrainTag())) &#123;</span><br><span class="line">                    result.setTrainTags(StrUtil.split(trainDO.getTrainTag(), <span class="string">&quot;,&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="variable">betweenDay</span> <span class="operator">=</span> cn.hutool.core.date.DateUtil.betweenDay(each.getDepartureTime(), each.getArrivalTime(), <span class="literal">false</span>);</span><br><span class="line">                result.setDaysArrived((<span class="type">int</span>) betweenDay);</span><br><span class="line">                result.setSaleStatus(<span class="keyword">new</span> <span class="title class_">Date</span>().after(trainDO.getSaleTime()) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">                result.setSaleTime(convertDateToLocalTime(trainDO.getSaleTime(), <span class="string">&quot;MM-dd HH:mm&quot;</span>));</span><br><span class="line">                seatResults.add(result);</span><br><span class="line">                regionTrainStationAllMap.put(CacheUtil.buildKey(String.valueOf(each.getTrainId()), each.getDeparture(), each.getArrival()), JSON.toJSONString(result));</span><br><span class="line">            &#125;</span><br><span class="line">            stringRedisTemplate.opsForHash().putAll(buildRegionTrainStationHashKey, regionTrainStationAllMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再获取到 <code>车票余额、车座次相对应的价格</code> 并进行缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">seatResults = CollUtil.isEmpty(seatResults)</span><br><span class="line">                ? regionTrainStationAllMap.values().stream().map(each -&gt; JSON.parseObject(each.toString(), TicketListDTO.class)).toList()</span><br><span class="line">                : seatResults;</span><br><span class="line">        seatResults = seatResults.stream().sorted(<span class="keyword">new</span> <span class="title class_">TimeStringComparator</span>()).toList();</span><br><span class="line">        <span class="keyword">for</span> (TicketListDTO each : seatResults) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">trainStationPriceStr</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">                    String.format(TRAIN_STATION_PRICE, each.getTrainId(), each.getDeparture(), each.getArrival()),</span><br><span class="line">                    String.class,</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        LambdaQueryWrapper&lt;TrainStationPriceDO&gt; trainStationPriceQueryWrapper = Wrappers.lambdaQuery(TrainStationPriceDO.class)</span><br><span class="line">                                .eq(TrainStationPriceDO::getDeparture, each.getDeparture())</span><br><span class="line">                                .eq(TrainStationPriceDO::getArrival, each.getArrival())</span><br><span class="line">                                .eq(TrainStationPriceDO::getTrainId, each.getTrainId());</span><br><span class="line">                        <span class="keyword">return</span> JSON.toJSONString(trainStationPriceMapper.selectList(trainStationPriceQueryWrapper));</span><br><span class="line">                    &#125;,</span><br><span class="line">                    ADVANCE_TICKET_DAY,</span><br><span class="line">                    TimeUnit.DAYS</span><br><span class="line">            );</span><br><span class="line">            List&lt;TrainStationPriceDO&gt; trainStationPriceDOList = JSON.parseArray(trainStationPriceStr, TrainStationPriceDO.class);</span><br><span class="line">            List&lt;SeatClassDTO&gt; seatClassList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            trainStationPriceDOList.forEach(item -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">seatType</span> <span class="operator">=</span> String.valueOf(item.getSeatType());</span><br><span class="line">                <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;_&quot;</span>, each.getTrainId(), item.getDeparture(), item.getArrival());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">quantityObj</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().get(TRAIN_STATION_REMAINING_TICKET + keySuffix, seatType);</span><br><span class="line">                <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> Optional.ofNullable(quantityObj)</span><br><span class="line">                        .map(Object::toString)</span><br><span class="line">                        .map(Integer::parseInt)</span><br><span class="line">                        .orElseGet(() -&gt; &#123;</span><br><span class="line">                            Map&lt;String, String&gt; seatMarginMap = seatMarginCacheLoader.load(String.valueOf(each.getTrainId()), seatType, item.getDeparture(), item.getArrival());</span><br><span class="line">                            <span class="keyword">return</span> Optional.ofNullable(seatMarginMap.get(String.valueOf(item.getSeatType()))).map(Integer::parseInt).orElse(<span class="number">0</span>);</span><br><span class="line">                        &#125;);</span><br><span class="line">                seatClassList.add(<span class="keyword">new</span> <span class="title class_">SeatClassDTO</span>(item.getSeatType(), quantity, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(item.getPrice()).divide(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;100&quot;</span>), <span class="number">1</span>, RoundingMode.HALF_UP), <span class="literal">false</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">            each.setSeatClassList(seatClassList);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>到这里，基本上就结束了，中间三个代码段都是 对车票部分进行查询、缓存，还有一部分不好的地方，我找个时间补上。</p><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>这个项目查询车票流程基本这样，对于 <code>网关</code> 实现方式多，本项目是通过继承 <code>AbstractGatewayFilterFactory</code> ，主要重写 <code>apply</code> 方法实现。</p><p>有很多代码写得很美，<br>像一开始的责任链模式进行参数校验，责任链实现在包<code>frameworks.designpattern</code>(前几太看的时候我还记得是如何加载的，现在我已经忘了T_T)<br>然后就是用 <code>@FunctionalInterface</code>只写一个接口，文中用了很多，举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;StationQueryRespDTO&gt; <span class="title function_">listAllStation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> distributedCache.safeGet(</span><br><span class="line">            STATION_ALL,</span><br><span class="line">            List.class,</span><br><span class="line">            () -&gt; BeanUtil.convert(stationMapper.selectList(Wrappers.emptyWrapper()), StationQueryRespDTO.class),</span><br><span class="line">            ADVANCE_TICKET_DAY,</span><br><span class="line">            TimeUnit.DAYS</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>() -&gt; BeanUtil.convert(stationMapper.selectList(Wrappers.emptyWrapper()), StationQueryRespDTO.class)</code> 是实现 <code>CacheLoader</code> 的 <code>load()</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CacheLoader</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">load</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>这有什么好处呢？</code></p><p>我们写这样一个接口，<code>通过函数式编程方式，直接写上实现。不用再依次写具体实现，然后再调用，极大增强复用性，查这个写一个实现，查那个写一个实现</code></p><p>雅，太雅了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 12306 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.17</title>
      <link href="/posts/10-17/"/>
      <url>/posts/10-17/</url>
      
        <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>先给看看工位。</p><img src="/img/10-17/gw.jpg" alt="自己的工位"/><p>经理给我配的旧的苹果，俺不会用，就给我配了Windows。果然 <code>野猪吃不了细康</code></p><p>工作一个多月了,按考勤算钱，第一个月又遇到国庆、中秋，那几天真希望自己天天上班，狠狠赚。</p><p>这个公司很小， <code>真正在干事儿的就6个人!其中还包括经理、包括我在内的三个实习生</code> 。但人家是19年就建立的。还有一位4年老员工。</p><p>第一天进公司，就收到通知被重庆德勤给录取了。但是我才租上房啊，还大老远从学校跑来，又坐车回去。<br><img src="/img/10-17/dqlq.jpg" alt="整洋文"><br>这俩工资是一样多的，但我不想多花父母的钱就没回重庆。爸给我说让我回去，我骗他说被撤回了。(小声bb一下，我也受到一些网络影响，说德勤分配完全看运气，有些好有些差。有大佬，有导师但完全看 <code>运气</code> )</p><p>也想过回重庆现在是不是已经有更好发展，是个高楼白领了，哈哈哈。</p><p>无所谓，在哪都是学。</p><p>我这儿的经理人挺好，说话都很和气，对实习生也不错，是个 <code>技术佬</code> 。我对这样的人啊，真是像个小孩一样。这几天犯了一个错，在人面前像个沙贝一样扭扭捏捏的，真想回去抽自己一个大嘴巴子。</p><p>前几天安排写一个脚本，从数据库上把数据扒出来，因为阿里那个数据库好像是只能上传，不能保存。<br>那是我第一个活儿，写得老快了， <code>感觉自己改的代码优雅丝滑</code>（现在想想就是傻呗迷之自信） ，越看越觉得自己屌，后面发现一些错误，又修修补补，又加上日志查看进度、配置文件。又这又那，感觉代码优雅得一批。<br>结果前天同事提醒我这个脚本有个BUG，某些情况会少数据。</p><p>哈哈哈， <code>结果我就急了</code> 。也没敢问经理，也没敢告诉他，因为我觉得这太easy了， <code>索性就把查到的2/3数据全删了</code> ，重头开始。(狂删自己巴掌，下次删片，别删数据)</p><p>哈哈哈，后端开发成全栈开发，让我页面美化，这真比不过同事，就让我很焦虑。</p><p>今天早上5点才睡着，8点多又拖着疲惫身躯上班了。</p><p>今天索性一问，说没事儿，让我接着查。<br>我都删了，拿啥查，又没给他说已经把数据删了。<br>结果他来问还差多少，我就实话实说了(为啥不早给他说)</p><p>生活，就是生下来，然后活着。</p><p>我现在就想挣钱，挣大把的钱。</p><p>听一首 DAY 1 好好睡一觉吧。接下来就好好工作，好好生活。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本站</title>
      <link href="/posts/%E6%9C%AC%E7%AB%99/"/>
      <url>/posts/%E6%9C%AC%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="关于本站"><a href="#关于本站" class="headerlink" title="关于本站"></a>关于本站</h1><p>其实很早之前一直想创建一个属于自己的博客。</p><p>从自己学习Java后端开始，就尝试过自己自研一个，后面发现自己写一个博客的工作量非常大，自己的前端学得也只是逻辑方面，对于美化方面做得很烂。</p><p>很早就了解到了有现成博客模板，折腾一下发现大量配置又给搁置了。</p><p>这一次终于下定决心了，一定要弄一个出来。</p><p>2024年10月13日</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
